<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://deku.posstree.com/ko/feed.xml" rel="self" type="application/atom+xml"/><link href="https://deku.posstree.com/ko/" rel="alternate" type="text/html"/><updated>2024-09-23T08:59:21+09:00</updated><id>https://deku.posstree.com/feed.xml</id><title type="html">Deku</title><subtitle>『Programming Artist, DeKu』</subtitle><author><name>dev.yakuza@gmail.com</name></author><entry xml:lang="ko"><title type="html">[GitHub Actions] 수동으로 GitHub Actions 실행하기</title><link href="https://deku.posstree.com/ko/github_actions/execute-github-actions-manually/" rel="alternate" type="text/html" title="[GitHub Actions] 수동으로 GitHub Actions 실행하기"/><published>2024-09-13T00:00:00+09:00</published><updated>2024-09-16T16:56:41+09:00</updated><id>https://deku.posstree.com/github_actions/execute-github-actions-manually-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/execute-github-actions-manually/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#workflow_dispatch">workflow_dispatch</a></li><li><a href="#inputs-%ED%83%80%EC%9E%85">inputs 타입</a></li><li><a href="#%EC%98%88%EC%A0%9C">예제</a><ul><li><a href="#boolean">boolean</a></li><li><a href="#choice">choice</a></li><li><a href="#number">number</a></li><li><a href="#string">string</a></li><li><a href="#environment">environment</a></li></ul></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>GitHub Actions를 사용하다보면 수동으로 GitHub Actions를 실행해야 할 때가 있습니다. 이번 블로그 포스트에서는 GitHub Actions를 수동으로 실행하는 방법에 대해서 알아보겠습니다.</p><h2 id="workflow_dispatch">workflow_dispatch</h2><p><code class="language-plaintext highlighter-rouge">GitHub Actions</code>를 수동으로 실행하기 위해서는 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>를 사용해야 합니다.</p><ul><li>공식 문서: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch</a></li></ul><p>이때, <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>을 통해 파라미터를 전달할 수 있습니다.</p><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>는 다음과 같이 설정할 수 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
</code></pre></div></div><h2 id="inputs-타입">inputs 타입</h2><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>에는 다음과 같은 종류가 있습니다.</p><ul><li><code class="language-plaintext highlighter-rouge">boolean</code>: true 또는 false</li><li><code class="language-plaintext highlighter-rouge">choice</code>: 미리 지정된 옵션 중 하나를 선택할 수 있는 SelectBox</li><li><code class="language-plaintext highlighter-rouge">number</code>: 숫자</li><li><code class="language-plaintext highlighter-rouge">string</code>: 문자열</li><li><code class="language-plaintext highlighter-rouge">environment</code>: GitHub에 설정한 환경 변수 사용</li></ul><p>공식 문서에서도 사용 가능한 <code class="language-plaintext highlighter-rouge">inputs</code> 타입을 확인할 수 있습니다.</p><ul><li>공식 문서: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype</a></li></ul><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>은 다음과 같이 설정할 수 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">inputs</code>은 <code class="language-plaintext highlighter-rouge">type</code>이외에도 <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">required</code>, <code class="language-plaintext highlighter-rouge">default</code>를 설정할 수 있습니다. <code class="language-plaintext highlighter-rouge">type</code>이외에는 모두 선택 사항입니다.</p><h2 id="예제">예제</h2><p>그럼 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>를 사용하여 GitHub Actions를 수동으로 실행하는 예제를 살펴보겠습니다.</p><h3 id="boolean">boolean</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.png" alt="Execute GitHub Actions manually - Boolean input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">boolean</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.png" alt="Execute GitHub Actions manually - Boolean input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="choice">choice</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_choice</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">choice</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">warning'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">choice</span>
        <span class="na">options</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s">info</span>
          <span class="pi">-</span> <span class="s">warning</span>
          <span class="pi">-</span> <span class="s">debug</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.png" alt="Execute GitHub Actions manually - Choice input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">choice</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.png" alt="Execute GitHub Actions manually - Choice input result"/></picture><h3 id="number">number</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_number</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">number</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="m">20</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">number</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input.png" alt="Execute GitHub Actions manually - Number input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">number</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.png" alt="Execute GitHub Actions manually - Number input result"/></picture><h3 id="string">string</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_string</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">string</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Hello,</span><span class="nv"> </span><span class="s">World!'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">string</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input.png" alt="Execute GitHub Actions manually - String input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">string</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.png" alt="Execute GitHub Actions manually - String input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="environment">environment</h3><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 에서 <code class="language-plaintext highlighter-rouge">environment</code> 타입을 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Settings</code>에서 <code class="language-plaintext highlighter-rouge">Environment</code>를 설정해야 합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environments.png" alt="Execute GitHub Actions manually - Environments"/></picture><p><code class="language-plaintext highlighter-rouge">New environment</code>를 클릭하고 다음과 같이 <code class="language-plaintext highlighter-rouge">Name</code>에 <code class="language-plaintext highlighter-rouge">dev</code>를 입력한 후, <code class="language-plaintext highlighter-rouge">Configure environment</code>를 클릭합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.png" alt="Execute GitHub Actions manually - New Dev Environment"/></picture><p>그런 다음 <code class="language-plaintext highlighter-rouge">Environment variables</code>의 <code class="language-plaintext highlighter-rouge">Add environment variable</code> 버튼을 누르고 다음과 같이 <code class="language-plaintext highlighter-rouge">Variable</code>을 추가합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.png" alt="Execute GitHub Actions manually - Dev environment variable"/></picture><p>동일한 방식으로 <code class="language-plaintext highlighter-rouge">prod</code>라는 환경에도 동일한 변수를 추가합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.png" alt="Execute GitHub Actions manually - Prod environment variable"/></picture><p>이제 수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_environment</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">environment</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">environment</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">environment</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.png" alt="Execute GitHub Actions manually - Environment input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Settings</code>에서 <code class="language-plaintext highlighter-rouge">Environment</code>에 설정한 값이 표시되는 것을 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><ul><li>dev 환경</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.png" alt="Execute GitHub Actions manually - Environment input result dev"/></picture><ul><li>prod 환경</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.png" alt="Execute GitHub Actions manually - Environment input result prod"/></picture><h2 id="완료">완료</h2><p>이것으로 GitHub Actions를 수동으로 실행하는 방법에 대해서 알아보았습니다. 또한 설정 가능한 <code class="language-plaintext highlighter-rouge">inputs</code> 타입에 대해서도 알아보았습니다.</p><p>여러분도 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>와 다양한 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>을 사용하여 GitHub Actions를 수동으로 실행해보세요.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[수동으로 GitHub Actions를 실행하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] 모노레포 환경에서 GitHub Actions로 PR 제목 검사하는 방법</title><link href="https://deku.posstree.com/ko/github_actions/action-check-pr-title/" rel="alternate" type="text/html" title="[GitHub Actions] 모노레포 환경에서 GitHub Actions로 PR 제목 검사하는 방법"/><published>2024-09-10T00:00:00+09:00</published><updated>2024-09-12T09:04:12+09:00</updated><id>https://deku.posstree.com/github_actions/action-check-pr-title-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/action-check-pr-title/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#action-check-pr-title">action-check-pr-title</a></li><li><a href="#github-actions-%EC%83%9D%EC%84%B1">GitHub Actions 생성</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>저는 <code class="language-plaintext highlighter-rouge">Release Drafter</code>를 사용하여 GitHub의 Release Note를 자동화하고 있습니다.</p><ul><li><a href="https://deku.posstree.com/ko/share/github-actions/release-drafter/" target="\_blank">[GitHub Actions] Release notes 자동화</a></li></ul><p>이 <code class="language-plaintext highlighter-rouge">Release Drafter</code>는 GitHub의 PR의 Label을 기준으로 동작합니다. <code class="language-plaintext highlighter-rouge">Release Drafter</code>는 Label을 자동으로 생성하는 기능을 제공하는데, 이때 PR의 제목을 사용합니다. 그래서 PR의 제목이 중요합니다.</p><p>기존에는 PR의 제목을 검사할 때, <a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>을 사용했습니다.</p><ul><li><a href="https://deku.posstree.com/ko/share/github-actions/pr-title-checker/" target="\_blank">[GitHub Actions] Pull request 제목 검사</a></li></ul><p>하지만 현재 모노레포 프로젝트에서는 해당 <code class="language-plaintext highlighter-rouge">Conventional PR Title Action</code>으로만은 충분하지 않아서 다른 GitHub Actions를 사용하게 되었습니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/repository_strategy/" target="\_blank">[프로젝트 관리] 리포지토리 전략</a></li></ul><p>이번 블로그 포스트에서는 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR을 생성했을 때, PR의 제목을 검사하는 방법에 대해서 알아보겠습니다.</p><h2 id="action-check-pr-title">action-check-pr-title</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>는 정규식을 사용하여 PR의 제목을 검사하는 GitHub Actions입니다.</p><ul><li><a href="https://github.com/Slashgear/action-check-pr-title" rel="nofollow noreferrer" target="\_blank">action-check-pr-title</a></li></ul><h2 id="github-actions-생성">GitHub Actions 생성</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR의 제목을 검사하는 GitHub Actions를 생성하기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/check_pr_title.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
      <span class="pi">-</span> <span class="s">reopened</span>
      <span class="pi">-</span> <span class="s">edited</span>
      <span class="pi">-</span> <span class="s">synchronize</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-pr-title</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Pull Request</code>의 제목을 검사하는 부분을 좀 더 자세히 살펴보겠습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>이 제공하는 <code class="language-plaintext highlighter-rouge">regexp</code>옵션을 사용하여 <code class="language-plaintext highlighter-rouge">PR</code>의 제목을 검사합니다. 여기서 사용하는 정규식은 다음과 같은 PR 제목을 허용합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feat<span class="o">(</span>SERVICE1<span class="o">)</span>: Add new feature
fix<span class="o">(</span>SERVICE2<span class="o">)</span>: Fix bug
refactor<span class="o">(</span>common<span class="o">)</span>: Refactor code
...
</code></pre></div></div><p>모노레포를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">Conventional Commits</code>의 <code class="language-plaintext highlighter-rouge">Scope</code> 영역에 서비스명을 설정하고, 이를 검사하도록 설정했습니다.</p><ul><li><a href="https://www.conventionalcommits.org/en/v1.0.0/" rel="nofollow noreferrer" target="\_blank">Conventional Commits</a></li></ul><h2 id="완료">완료</h2><p>이것으로 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR을 생성했을 때, PR의 제목을 검사하는 방법에 대해서 알아보았습니다. 기존에 사용하던 <a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>으로도 정규식 검사가 가능하지만, 설정이 간단하지 않아서 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하게 되었습니다.</p><p>여러분도 간단하게 정규식으로 PR 제목을 검사하고 싶다면 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[모노레포 환경에서 GitHub Actions를 사용하여 PR을 생성했을 때, PR(Pull Request)의 제목을 검사하는 방법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] GitHub Actions로 브랜치 이름을 검사하는 방법</title><link href="https://deku.posstree.com/ko/github_actions/check-branch-name" rel="alternate" type="text/html" title="[GitHub Actions] GitHub Actions로 브랜치 이름을 검사하는 방법"/><published>2024-09-02T00:00:00+09:00</published><updated>2024-09-09T09:52:51+09:00</updated><id>https://deku.posstree.com/github_actions/check-branch-name-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/check-branch-name"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%9D%B4%EB%A6%84-%EB%B3%80%EA%B2%BD">브랜치 이름 변경</a></li><li><a href="#git-hooks">Git hooks</a><ul><li><a href="#%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%9D%B4%EB%A6%84-%EA%B2%80%EC%82%AC-script-%EC%83%9D%EC%84%B1">브랜치 이름 검사 script 생성</a></li><li><a href="#husky-%EC%84%A4%EC%A0%95">Husky 설정</a></li><li><a href="#lefthook-%EC%84%A4%EC%A0%95">Lefthook 설정</a></li></ul></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>Git을 사용하여 프로젝트를 개발할 때, 다음 링크와 같이 브랜치 전략을 사용하게 됩니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/branch-strategy/" target="\_blank">소프트웨어 개발을 위한 브랜치 전략</a></li></ul><p>이때 브랜치 전략에 맞게 브랜치를 만들고 있는지 관리가 필요할 때가 있습니다.</p><p>이번 블로그 포스트에서는 GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보도록 하겠습니다.</p><h2 id="github-actions">GitHub Actions</h2><p>브랜치 이름을 검사하는 GitHub Actions를 생성하기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/check-branch-name.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-branch-name</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
</code></pre></div></div><p>이 GitHub Actions를 좀 더 자세히 살펴보도록 하겠습니다.</p><p>저는 모노레포로 프로젝트를 관리하고 있습니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/repository_strategy/" target="\_blank">[프로젝트 관리] 리포지토리 전략</a></li></ul><p>그래서 다음과 같은 브랜치 이름을 사용하고 있습니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature/:SERVICE_NAME/:BRANCH_NAME
release/:SERVICE_NAME/:BRANCH_NAME
fix/:SERVICE_NAME/:BRANCH_NAME
...
</code></pre></div></div><p>이때 브랜치명이 <code class="language-plaintext highlighter-rouge">dependabot</code>, <code class="language-plaintext highlighter-rouge">hotfix</code><code class="language-plaintext highlighter-rouge">release</code>, <code class="language-plaintext highlighter-rouge">review</code>, <code class="language-plaintext highlighter-rouge">feature</code>, <code class="language-plaintext highlighter-rouge">fix</code>, <code class="language-plaintext highlighter-rouge">sub-feature</code> 등으로 시작하는지 확인하고 <code class="language-plaintext highlighter-rouge">SERVICE_NAME</code>을 추출하여 미리 정의한 이름을 사용하는지 확인하고 있습니다.</p><p>그래서 다음과 같이 서비스명과 브랜치명을 미리 추출하여 환경 변수에 저장하였습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
<span class="s">...</span>
</code></pre></div></div><p>이렇게 추출한 브랜치명과 서비스명을 미리 정의한 값과 비교하여 브랜치명과 서비스명이 유효한지 확인하고 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
<span class="s">...</span>
</code></pre></div></div><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="브랜치-이름-변경">브랜치 이름 변경</h2><p>이 GitHub Actions를 사용하면 미리 정의된 규칙에 맞지 않는 브랜치명으로 PR을 생성하면 에러가 발생하게 됩니다. 이때는 다음과 같이 브랜치명을 변경하면 됩니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;current-branch-name&gt;
git branch <span class="nt">-m</span> &lt;new-branch-name&gt;
</code></pre></div></div><p>또는 다음과 같이 변경이 가능합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-m</span> &lt;current-branch-name&gt; &lt;new-branch-name&gt;
</code></pre></div></div><p>이렇게 브랜치명을 변경하였다면 새로운 PR을 생성하고 기존 PR은 닫아주시면 됩니다.</p><h2 id="git-hooks">Git hooks</h2><p>잘못된 브랜치명을 사용한 경우, 이 GitHub Actions로 검사가 가능하지만, PR을 생성하지 않으면 검사가 불가능합니다. 또한, 브랜치명이 잘못된 경우 기존 PR을 닫고 새로운 PR을 생성해야 합니다.</p><p>이때 Git hooks를 사용하면 PR을 생성하기 전에 미리 브랜치명을 검사하면 불필요한 작업을 줄일 수 있습니다.</p><h3 id="브랜치-이름-검사-script-생성">브랜치 이름 검사 script 생성</h3><p>브랜치 이름을 검사하는 script를 생성하기 위해 <code class="language-plaintext highlighter-rouge">scripts/check-branch-name.sh</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

<span class="nv">pattern</span><span class="o">=</span><span class="s1">'^(dependabot|hotfix|release|review|feature|fix|sub-feature)/(npm_and_yarn|github_actions|SERVICE_1|SERVICE_2|template|components|config|common)/.*'</span>
<span class="nv">errorMessage</span><span class="o">=</span><span class="s1">'Invalid branch name. Please follow the correct naming convention.'</span>

<span class="k">if</span> <span class="o">!</span> git rev-parse <span class="nt">--is-inside-work-tree</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Error: Not inside Git working tree."</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">branches</span><span class="o">=</span><span class="si">$(</span>git branch | <span class="nb">grep</span> <span class="s1">'^\*'</span> | <span class="nb">sed</span> <span class="s1">'s/^\* //'</span><span class="si">)</span>

<span class="k">if </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-Eq</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[32mPassed</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
<span class="k">else
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[31mResult: failed</span><span class="se">\n</span><span class="s2">Error Msg: %s</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>
</code></pre></div></div><h3 id="husky-설정">Husky 설정</h3><p>Husky를 사용하여 Git hooks를 설정하려면 다음과 같이 <code class="language-plaintext highlighter-rouge">.husky/pre-commit</code> 파일을 수정합니다.</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">validation</span><span class="w"> </span><span class="err">branch</span><span class="w"> </span><span class="err">name</span><span class="w">
</span><span class="err">.</span><span class="w"> </span><span class="s2">"$(dirname -- "</span><span class="err">$</span><span class="mi">0</span><span class="s2">")/scripts/validateBranchName.sh"</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span><span class="err">yarn</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span></code></pre></div></div><p>이때 앞서 만든 <code class="language-plaintext highlighter-rouge">check-branch-name.sh</code> 파일은 <code class="language-plaintext highlighter-rouge">.husky/scripts/validateBranchName.sh</code>에 이동시켜야 합니다.</p><h3 id="lefthook-설정">Lefthook 설정</h3><p>Lefthook를 사용하여 Git hooks를 설정하려면 다음과 같이 <code class="language-plaintext highlighter-rouge">.lefthook.yml</code> 파일을 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pre-push</span><span class="pi">:</span>
  <span class="na">scripts</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">validateBranchName.sh"</span><span class="err">:</span>
      <span class="na">runner</span><span class="pi">:</span> <span class="s">bash</span>
</code></pre></div></div><p>이때 앞서 만든 <code class="language-plaintext highlighter-rouge">check-branch-name.sh</code> 파일은 <code class="language-plaintext highlighter-rouge">.lefthook/pre-commit/validateBranchName.sh</code>에 이동시켜야 합니다.</p><h2 id="완료">완료</h2><p>이것으로 GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보았습니다. 또한 Git hooks를 사용하여 PR을 생성하기 전에 브랜치명을 검사하는 방법에 대해서도 알아보았습니다.</p><p>만약 저처럼 프로젝트에서 브랜치명이 중요한 역할을 한다면 이 GitHub Actions와 Git Hooks를 사용하여 브랜치명을 검사해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] PR에 자동으로 Assignees 추가하기</title><link href="https://deku.posstree.com/ko/github_actions/auto-assing-assigness" rel="alternate" type="text/html" title="[GitHub Actions] PR에 자동으로 Assignees 추가하기"/><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-30T09:57:08+09:00</updated><id>https://deku.posstree.com/github_actions/auto-assing-assigness-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/auto-assing-assigness"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#github-actions-%EC%83%9D%EC%84%B1">GitHub Actions 생성</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>보통 개발을 완료한 후, 개발을 담당한 개발자가 GitHub에서 PR(Pull Request)을 생성하고, 자기 자신을 <code class="language-plaintext highlighter-rouge">Assignees</code>에 추가합니다. 하지만, 매번 PR을 생성할 때마다 <code class="language-plaintext highlighter-rouge">Assignees</code>에 자기 자신을 추가하는 것은 번거롭습니다.</p><p>이번 블로그 포스트에서는 GitHub Actions를 사용하여 PR을 생성할 때마다 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>에 PR을 생성하는 개발자를 추가하는 방법에 대해서 알아보겠습니다.</p><h2 id="github-actions-생성">GitHub Actions 생성</h2><p>PR에 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>를 추가하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/auto-assign-assignees.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Assign assignees</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p>이 GitHub Actions를 좀 더 자세히 살펴보도록 하겠습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
<span class="nn">...</span>
</code></pre></div></div><p>이 GitHub Actions은 PR이 생성될 때 실행됩니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">if</span><span class="err">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="s">...</span>
</code></pre></div></div><p>저는 GitHub에서 Dependabot을 사용하고 있습니다. Dependabot이 생성한 PR의 Assignees에 Dependabot을 추가할 수 없으므로, Dependabot이 생성한 PR에는 Assignees를 추가하지 않도록 설정했습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">steps</span><span class="err">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">GitHub</code>이 제공하는 GitHub Actions을 사용하여 JavaScript 코드로 PR을 생성하는 개발자(<code class="language-plaintext highlighter-rouge">context.actor</code>)를 <code class="language-plaintext highlighter-rouge">Assignees</code>에 추가하는 코드를 작성했습니다.</p><h2 id="완료">완료</h2><p>이것으로 PR을 생성할 때마다 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>에 PR을 생성하는 개발자를 추가하는 GitHub Actions를 만드는 방법에 대해서 알아보았습니다. 여러분도 이 GitHub Actions를 사용하여 수동으로 설정하던 Assignees를 자동으로 설정해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actions를 사용하여 PR에 자동으로 Assignees를 추가하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">전문가가 되기 위한 의도적 수련</title><link href="https://deku.posstree.com/ko/essay/deliberate-practice-to-become-expert/" rel="alternate" type="text/html" title="전문가가 되기 위한 의도적 수련"/><published>2024-08-26T00:00:00+09:00</published><updated>2024-09-17T11:48:36+09:00</updated><id>https://deku.posstree.com/essay/deliberate-practice-to-become-expert-ko</id><content type="html" xml:base="https://deku.posstree.com/essay/deliberate-practice-to-become-expert/"><![CDATA[<p>우리는 평생 양치질을 하고, 평생 숨을 쉬지만 양치질의 전문가도, 숨쉬기의 전문가도 되지는 못한다.</p><p>이렇게 평생 어떤 것을 하지만, 그것에 대한 전문가가 되지 못하는 이유는, 그 일을 하는 동기와 한 행동에 대한 피드백이 부족하기 때문이다.</p><p>어떤 것의 전문가가 되려면 전문가가 되려는 부분에서 <code class="language-plaintext highlighter-rouge">실력을 개선하려는 동기</code>가 있어야 하고, 실력 개선 활동에 대한 <code class="language-plaintext highlighter-rouge">적절한 시기에 구체적인 피드백</code>을 받으며 이를 꾸준히 반복해야 한다.</p><p>의도적 수련은 이러한 동기와 피드백을 통해 전문성을 향상시키는 방법이다.</p><h2 id="타당성과-피드백">타당성과 피드백</h2><p>전문성이 형성되려면 동기와 피드백이외에도 <code class="language-plaintext highlighter-rouge">타당성</code>이 필요하다. 타당성은 어떤 작업에 인과 관계와 규칙성이 존재하고 결과에 대한 예측 가능성이 있다는 것을 의미한다.</p><p>이처럼 타당성이 높은 영역은 자신이 한 행동에 대한 결과를 확인할 수 있고, 이는 곧 작업에 대한 피드백이 된다.</p><p>타당성과 피드백이 있는 환경에서는 자신이 한 행동에 대한 결과를 알 수 있고, 이를 통해 학습할 기회가 주어진다.</p><blockquote><p>공항의 보안 검사대 조사원들은 자신이 오늘 얼마나 실수를 했는지 알 수 있는 방법이 없다. 가방에서 칼이나 액체 물질을 얼마나 찾았는지는 알아도 얼마나 놓쳤는지는 알 수 없기 때문이다.</p></blockquote><p>공항 보안 검사대의 조사원들은 타당성과 피드백이 있는 환경이 아니기 때문에 전문가가 되기 어렵다. 이처럼 피드백이 부족한 환경에서는 아무리 오래 일을 해도 전문가가 될 수 없다.</p><p>어떤 직업에서는 전문성이 형성되는 작업과 전문성을 형성하기 어려운 작업 모두가 존재하기도 한다.</p><blockquote><p>의사가 환자를 진단할 때, 잘못 진단을 했는지 알 수 있는 방법이 없다. 그러므로 이 부분에서는 전문성을 향상시키기 어렵다. 하지만, 수술을 할 때는 수술 후 환자의 상태를 보고 수술이 잘 됐는지 판단할 수 있기 때문에 수술을 통해 전문성을 향상시킬 수 있다.</p></blockquote><p>내가 속한 업계가 타당성과 피드백이 부족한 업계이므로 전문성 향상을 할 수 없다고 전문가가 되는 것을 포기해서는 안된다. 현재 일하는 방식을 바꿔 타당성과 피드백을 높이면 충분히 전문가가 될 수 있다.</p><p>타당성을 높이기 위해서는 업무에서 변수를 설정하고, 해당 변수를 수정하는 실험을 하면서 규칙성과 인과 관계를 찾으려는 노력을 해야 한다.</p><p>피드백을 높이기 위해서는 동료나 상사, 고객에게서 혹은 내가 하는 업무로부터 직접 피드백을 받으려 노력해야 한다. 나처럼 개발자인 경우는 동료나 상사로부터 코드 리뷰를 받거나 정적 분석 도구 또는 테스트 코드를 통해 피드백을 받을 수 있다.</p><h2 id="난이도">난이도</h2><p>실력을 높이기 위해서는 <code class="language-plaintext highlighter-rouge">의도적 수련</code>이 중요하다. 1만 시간의 법칙처럼 수련의 양적인 부분을 강조하는 경우는 많지만, 질적인 부분을 강조하는 경우는 적다.</p><p>의도적 수련의 필수 조건중 하나는 적절한 <code class="language-plaintext highlighter-rouge">난이도</code>이다. 의도적 수련이 되려면 나의 실력과 작업의 난이도가 비슷해야 한다. 이것은 미하이 칙센트미하이(Mihaly Csikszentmihalyi)의 몰입 이론과도 일치한다.</p><picture><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.avif" type="image/avif"/><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.webp" type="image/webp"/><img src="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.jpg" alt="Deliberate practice to become an expert: Flow"/></picture><p>가로축은 해당 작업에 대해 자신이 느끼는 자기 실력을 말하며, 세로축은 해당 작업에 대해 자신이 느끼는 난이도이다.</p><p><code class="language-plaintext highlighter-rouge">Boredom 영역</code>의 일은 실력이 작업 난이도보다 높은 영역이다. 이 일을 하게 되면 처음에는 편한 일을 담당하게 되어 너무 좋다고 생각하지만 조금 지나면 일에 대해 <code class="language-plaintext highlighter-rouge">지루함</code>을 느끼게 된다.</p><p><code class="language-plaintext highlighter-rouge">Anxiety 영역</code>은 실력보다 난이도가 높은 작업의 영역이다. 이 영역에서는 해당 작업에 대해 모르는 것들이 많고 자신의 실력으로 해결할 수 없다는 <code class="language-plaintext highlighter-rouge">불안함</code>이나 <code class="language-plaintext highlighter-rouge">두려움</code>을 느끼게 된다.</p><p><code class="language-plaintext highlighter-rouge">Apathy-Flow 영역</code>은 난이도와 실력이 엇비슷한 영역이다. 미하이 칙센트미하이는 이 부분에서 인간이 <code class="language-plaintext highlighter-rouge">몰입</code>을 경험한다고 한다. 인간이 몰입 상태가 되면 최고 수준의 집중력을 보이고, 퍼포먼스나 학습 능력이 최대치가 될 수 있다고 한다. 그리고 그 때 최고 수준의 행복감을 경험한다고 한다.</p><p>언어학자인 크래센(Stephen Krashen)의 입력 가설(i+1 이론)에서는 학습자의 언어 수준을 i라고 할 때, 딱 한 단계 높은 i+1 수준의 입력이 주어질 때에만 언어 능력이 유의미하게 발전한다고 한다.</p><p>교육학에는 인지부하이론(Cognitive load theory)이라는 이론이 있다. 이 이론은 학습시 불필요하게 인지적인 부담을 주면 어떤 것도 제대로 학습하기 어렵다는 이론이다. 예를 들어 미적분같이 어려운 개념을 자신이 잘 모르는 언어인 독일어로 배우면, 미적분 자체보다는 다른 것들에 에너지를 빼앗겨 학습 효율이 떨어진다. 반대로 영어 단어를 외울때는 모음을 가리고 외우면 <code class="language-plaintext highlighter-rouge">더 어려워서</code> 오히려 기억이 기억이 오래 갈 수 있다는 연구도 있다.</p><p>이런 연구 결과를 통해서 알 수 있는 중요한 사실은 실력을 향상시키기 위해서는 적절한 난이도가 필요하다는 것이다.</p><p>만약 자신이 업무 시간중에 불안함이나 지루함을 느낀다면, 이는 실력을 향상시킬 수 있는 환경에 있지 않다는 것이다. 문제는 이런 환경에 익숙해지고 행동이 습관화되면 이런 인식 자체도 잘 되지 않는다는 것이다.</p><p>이는 <a href="https://www.researchgate.net/publication/312624160_An_examination_of_the_practice_environments_in_figure_skating_and_volleyball_A_search_for_deliberate_practice" rel="nofollow noreferrer" target="_blank">An examination of the practice environments in figure skating and volleyball: A search for deliberate practice</a> 연구 결과에서 확인할 수 있다.</p><blockquote><p>지역 대회 수준의 선수와 세계 대회 수준의 선수 두 그룹을 서로 비교해 봤습니다. 우선 하루 연습을 끝낸 후 간단한 설문을 통해 여러 가지를 묻습니다. 그 중 하나가 오늘 연습 중 트리플 악셀을 몇번 정도 했다고 기억하는가 하는 질문입니다. 두 그룹의 응답에는 큰 차이는 없었습니다. 하지만 두 그룹의 실제 연습 장면을 녹화해서 분석한 결과, 세계 대회 수준의 선수는 지역 대회 수준의 선수에 비해 몇 배 더 많은 트리플 악셀을 연습했습니다. 지역 대회 수준의 선수는 자신들이 이미 익숙하고 자신있는 ‘예술적 표현’ 등과 같은 연습에 시간을 더 썼습니다. 그러고는 트리플 악셀을 많이 연습했다고 착각했습니다.</p></blockquote><p>이 연구 결과에서처럼 인간은 자신의 처한 환경에 익숙해지고, 익숙해진 환경에서는 자기 인식을 잘 못하게 된다.</p><h2 id="의도적-수련">의도적 수련</h2><p>우리는 미하이 칙센트미하이의 몰입 이론을 바탕으로 의도적 수련을 할 수 있다.</p><picture><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.avif" type="image/avif"/><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.webp" type="image/webp"/><img src="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.jpg" alt="Deliberate practice to become an expert: Deliberate practice"/></picture><p>그림과 같이 우리는 총 네가지 의도적 수련을 할 수 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">A1</code>: 실력 낮추기</li><li><code class="language-plaintext highlighter-rouge">A2</code>: 난이도 높이기</li><li><code class="language-plaintext highlighter-rouge">B1</code>: 난이도 낮추기</li><li><code class="language-plaintext highlighter-rouge">B2</code>: 실력 높이기</li></ul><p>이 의도적 수련은 실력을 향상시키기 위해서는 반드시 해야 한다. 그렇지 않으면 우리의 실력은 향상되지 않을 뿐만 아니라 피겨스케이팅의 연구 결과 처럼 실력이 향상되고 있다는 착각에 빠질 수 있다.</p><h3 id="a1-실력-낮추기">A1: 실력 낮추기</h3><p>작업의 난이도는 그대로 두고, 자기의 실력을 낮추는 의도적 수련 방법이다. 예를 들어 체력 훈련을 할 때, 팔과 다리에 모래 주머니를 달고 운동을 하는 것이다.</p><p>나와 같이 개발자라면 자신의 개발을 효율적으로 하거나 좀 더 편하게 하기 위한 툴을 사용하지 않음으로써 이런 의도적 수련을 할 수 있다. 예를 들어 ESLint나 Prettier와 같은 정적 코드 분석기를 실시간으로 사용하지 않고 코딩하거나, 자주 사용하는 IDE 또는 텍스트 에디터가 아닌 툴을 사용하거나, 마우스를 자주 사용한다면 키보드만으로 개발을 하거나, 디버거를 쓰지 않고 개발하는 등 개발의 편리함이나 효율성을 위한 툴을 사용하지 않으므로써 자신의 실력을 낮춰 의도적 수련을 하는 것이다. 툴들이 늘 해주던 것을 자신의 힘으로만 해결해야함으로 이전보다 더 많은 생각을 하게되어 집중도가 올라가게 된다.</p><h3 id="a2-난이도-높이기">A2: 난이도 높이기</h3><p>실력은 그대로 두고 작업의 난이도를 높이는 의도적 수련 방법이다.</p><blockquote><p>1965년 샌프란시스코에서의 결투가 이소룡이 웨이트 트레이닝에 박차를 가하게 된 계기가 되었다. 당시 이소룡은 사람들에게 쿵푸를 막 가르치기 시작했던 시기이다. 전통 무술을 하던 사람 중 하나가 이소룡이 서양인을 가르친다는 걸 듣고 도전을 하러 찾아왔고, 이소룡의 아내 린다 리가 그 장면을 목격했다. “약 3분 정도 진행되었죠. 브루스가 그분을 땅에 쓰러뜨리고는 말했어요. ‘이제 포기하시겠어요?’ 그러자 그 남자가 ‘포기합니다’라고 했죠. 그러고 그들 일행은 샌프란시스코로 돌아갔어요. 하지만 브로스는 무진장 화가 났어요. 3분이 되기 전에 그 사람을 쓰러뜨리지 못했다고요. 그때부터였죠. 브루스가 자신의 육체적 건강 수준과 무술 방식에 대해 회의를 품기 시작한게” - How Bruce Lee Changed the World, 디스커버리 채널, 2009.</p></blockquote><p>이소룡의 예처럼 무술을 너무 잘하면 상대방과의 싸움이 쉬워질 수 있다. 이때, ‘3분이내에 이기기’ 등과 같이 자신만의 제약을 추가하여 작업의 난이도를 높일 수 있다.</p><p>뛰어난 프로그래머들은 이 방법을 많이 사용하고 있다. 예를 들면, 하루만에 개발하라고 주어진 업무를 한 시간만에 완료하는 방법을 생각해 본다라던지 UI의 느린 반응 속도를 빠르게 만들도록 프로그램을 리팩토링한다던지, 매일 버그나 문제점을 하나씩만 찾았다면 오늘은 두개를 찾도록 노력한다던지, 익숙하지 않은 새로운 언어로 코딩을 하는 등을 통해 이 의도적 수련을 수행할 수 있다.</p><p>또 다른 방법으로는 공식적으로 안해도 되는 업무를 자신의 의지로 추가하는 경우가 있다. 예를 들어 자신의 업무를 개선하는 작업으로 리팩토링을 하거나 자동화 테스트를 추가하거나 자신만의 도구(방법)을 개발하는 것이다.</p><p>A2 방법에서는 특히 자신만의 도구와 방법을 만드는게 매우 중요하다. 인지심리학에서 상대의 전문성을 빠르게 파악하는 기법중 하나로, ‘남들보다 일을 좀 더 효율적으로, 효과적으로 하기위해 내가 직접 만들어 쓰는 나만의 도구나 방법’이 있는지 묻는 방법이 있다. 자주 일어나는 반복 패턴을 파악하고 분석하여 부족한 시간에도 짬을 내어 도구를 고안하고 작성해야 한다. 이렇게 도구를 만들면 기존의 난이도 보다 높아지게 되고, 이를 통해 실력이 향상된다. 뿐만아니라 이렇게 만든 도구가 나의 업무를 더욱 효율적이고 효과적으로 만들어 주므로 나의 전문성을 높이는데 큰 도움이 된다.</p><h3 id="b1-난이도-낮추기">B1: 난이도 낮추기</h3><p>난이도가 실력보다 높은 경우 난이도를 낮춤으로써 의도적 수련을 하는 방법이다. 높은 난이도의 과제를 자신의 능력으로 만들 수 있는 대체 기능으로 개발해 보거나 좀 더 쉬운 작은 과제로 나누어 처리하는 방법이다.</p><p>이런 방법을 사용하는데 주의해야 할 점이 있다. 실력과 난이도는 수시로 바뀐다는 것이다. 어제까지 잘 안되서 고민하던 문제가 오늘 갑자기 잘 풀린다던지, 쉬운 과제로 생각했지만 버그가 발생하여 난이도가 급격히 상승할 수도 있다. 또는 내가 시도한 방법이 잘못되어 난이도를 너무 많이 높이는 것도 이에 해당한다.</p><p>그러므로 이 방법은 유동적으로 사용해야 한다. 작업 난이도가 높아 낮은 난이도로 나눴더니 각각의 난이도가 너무 낮아 지루함을 느낀다면 다시 난이도를 높이거나 실력을 낮춰야 한다. 작업을 하는 동안 실력이 올라가 난이도가 쉬워졌다면 이에 맞게 다시 조정해야 한다.</p><h3 id="b2-실력-높이기">B2: 실력 높이기</h3><p>실력보다 난이도가 높은 경우 실력을 높이는 의도적 수련 방법이다.</p><p>실력을 올리기 위해서는 다음과 같은 방법을 시도할 수 있다.</p><ul><li>책</li><li>스터디 그룹</li><li>교육</li></ul><p>하지만 이 방법은 장기적으로 실력을 향상 시키는 방법이다. 현재 난이도가 자신의 실력보다 높아, 실력을 높이기에는 시간이 너무 오래 걸린다. 그럼 단기적으로 실력을 향상시키는 방법은 무엇이 있을까?</p><p>단기적으로 실력을 향상시키기 위해서는 사회적 접근, 도구적 접근, 내관적 접근을 사용할 수 있다.</p><p>사회적 접근은 나보다 뛰어난 전문가의 도움을 받는 것이다. 잘하는 멤버에게 짝 프로그래밍을 제안하거나, 인터넷에서 검색을 하거나 커뮤니티에 글을 올려 도움을 요청하는 방법, 공식 문서를 참고하는 방법 등이 이에 해당한다.</p><p>도구적 접근은 도구의 도움을 받는 것이다. 더 나은 디버거, 자동 통합 도구, 코드 분석 툴, 오픈소스 사용 등이 이에 해당한다.</p><p>내관적 접근은 비슷한 일을 했던 경험을 떠올려 보면서 비유적으로 문제를 해결하는 방법이다.</p><h2 id="리더가-할-수-있는-일">리더가 할 수 있는 일</h2><p>리더로서는 팀원들에게 실력에 맞는 적절한 업무를 주고, 팀원들의 상태를 파악하면서 앞서 소개한 의도적 수련 방법을 적절하게 구사할 수 있도록 도와줘야 한다. 하지만 이는 이상적인 상태이며 이를 수행한다는 것은 매우 어렵다.</p><p>그러므로 리더는 개개인 각자가 이런 의도적 훈련 방법을 실천할 수 있는 환경과 능력을 만들어 주는 것이 중요하다.</p><h2 id="일상에서의-의도적-수련">일상에서의 의도적 수련</h2><p>의도적 수련은 업무뿐만 아니라 일상 생활에서도 적용할 수 있다. 이렇게 한가지 영역에서의 교훈을 다른 영역에 적용하는 것을 심리학에서는 학습 전이라고 한다.</p><p>여러분도 이런 의도적 수련을 업무와 일상 생활에 적용하여 업무에서의 전문가, 삶에 대한 전문가가 되어보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="essay"/><summary type="html"><![CDATA[평생 같은 일을 반복해도 전문가가 될 수 없다. 전문가가 되기 위해서는 의도적 수련이 필요하다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/essay/2024/deliberate-practice-to-become-expert/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/essay/2024/deliberate-practice-to-become-expert/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">VSCode에서 Monorepo를 위한 ESLint 설정하기</title><link href="https://deku.posstree.com/ko/environment/vscode/eslint-configuration-for-monorepo" rel="alternate" type="text/html" title="VSCode에서 Monorepo를 위한 ESLint 설정하기"/><published>2024-08-22T00:00:00+09:00</published><updated>2024-08-27T20:01:47+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-eslint-configuration-for-monorepo-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/eslint-configuration-for-monorepo"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#vscode%EC%9D%98-current-working-directory">VSCode의 Current working directory</a></li><li><a href="#vscodesettingsjson-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95">vscode/settings.json 파일 수정</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>Monorepo 환경에서는 여러 패키지를 하나의 리포지토리에 관리하기 때문에, 각 패키지마다 개별적인 ESLint 설정이 필요할 때가 있습니다. 이때 ESLint가 어느 디렉터리를 기준으로 작동할지 결정하는 것이 중요합니다.</p><p>이번 블로그 포스트에서는 Visual Studio Code(VSCode)에서 Monorepo 프로젝트에서 ESLint의 Current Working Directory(CWD)를 설정하는 방법을 알아보겠습니다.</p><h2 id="vscode의-current-working-directory">VSCode의 Current working directory</h2><p>VSCode에서 특별한 설정을 하지 않는다면, ESLint는 루트 폴더에 있는 ESLint 설정 파일을 기준으로 동작합니다. 하지만, Monorepo 프로젝트에서는 각각의 프로젝트마다 ESLint 설정 파일이 있을 수 있습니다.</p><p>이때, VSCode에서 ESLint의 Current Working Directory(CWD)를 설정하면, ESLint가 해당 디렉터리를 기준으로 동작하게 됩니다.</p><h2 id="vscodesettingsjson-파일-수정">.vscode/settings.json 파일 수정</h2><p>다음은 VSCode에서 ESLint의 Current Working Directory(CWD)를 설정하는 방법입니다.</p><ol><li>mode 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"auto"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>이렇게 설정하면, VSCode는 ESLint 설정 파일이 있는 디렉터리를 자동으로 찾아서 CWD로 설정합니다.</p><ol><li>pattern 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"./packages/*/"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Glob</code> 패턴으로 CWD가 될 디렉터리를 설정할 수도 있습니다.</p><ol><li>디렉토리 지정 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"./packages/package1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"./packages/package2"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>이와 같이 배열로 특정 디렉터리를 지정할 수도 있습니다.</p><h2 id="완료">완료</h2><p>이것으로 VSCode에서 Monorepo 프로젝트를 개발할 떄, ESLint의 Current Working Directory(CWD)를 설정하는 방법에 대해서 알아보았습니다.</p><p>저는 <code class="language-plaintext highlighter-rouge">"mode": "auto"</code>를 설정하여 사용하고 있습니다. 특별한 문제가 없다면 이 설정을 사용하는 것을 추천합니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[Monorepo 프로젝트를 개발할 때, VSCode에서 ESLint를 설정하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[에세이] AI 시대에서 살아 남기 위한 학습 방법</title><link href="https://deku.posstree.com/ko/essay/how-to-survive-in-ai-era/" rel="alternate" type="text/html" title="[에세이] AI 시대에서 살아 남기 위한 학습 방법"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-25T20:50:59+09:00</updated><id>https://deku.posstree.com/essay/how-to-survive-in-ai-era-ko</id><content type="html" xml:base="https://deku.posstree.com/essay/how-to-survive-in-ai-era/"><![CDATA[<p>다음과 같은 조건은 AI가 학습하기 쉬운 조건이다.</p><ol><li>목표(Goal)가 분명하고 객관적이며 정적이다.</li><li>매 순간 선택할 수 있는 행동과 선택의 종류가 유한하다.</li><li>매 순간 자신의 선택에 의해 목표에 얼마나 근접했는지를 알 수 있다.</li><li>주로 예상 못 한 외부 요소의 영향이 없는 닫힌 시스템이다.</li><li>목표 도달을 위한 선택과 결과에 대한 자료가 많다.</li></ol><p>이런 상황은 AI뿐만 아니라 인간도 학습하기 좋은 조건이다.</p><p>제임스 샨토(James Shanteau)가 발표한 <a href="https://www.researchgate.net/publication/4815960_Competence_in_Experts_The_Role_of_Task_Characteristics" rel="nofollow noreferrer" target="_blank">Competence in Experts: The Role of Task Characteristics</a> 연구에 따르면, 피드백이 주어지고 작업이 반복되며 객관적 분석이 가능한 경우에 해당 직업에서 전문성이 잘 드러난다고 한다.</p><p>그러나 이런 전문성이 잘 들어나는 직업이 현재는 AI가 학습하기 좋은 조건을 가졌다고 볼 수 있다.</p><p>인간이 학습하기 쉬운 환경은 AI도 학습하기 쉬운 환경이므로 이런 일은 언젠가 AI에게 자리를 내줘야 할지 모른다. 그러므로 AI 시대에서 살아남기 위해서는 학습하기 힘든 환경에서 학습하기 힘든 주제를 골라야 한다.</p><p>학습하기 힘든 조건은 다음과 같다.</p><ol><li>목표가 모호하고 주관적이며 동적이다.</li><li>매 순간 선택할 수 있는 행동과 선택 종류가 무한하다.</li><li>매 순간 자신의 선택에 의해 목표에 얼마나 근접했는지를 알 수 없다.</li><li>주로 예상 못 한 외부 요소에 영향을 받는 열린 시스템이다.</li><li>목표 도달을 위한 선택과 결과에 대한 자료가 부족하다.</li></ol><p>이런 조건은 인간이 학습하기 어렵고, 특히 AI가 학습하기에는 더 어렵다.</p><p>또한 독창성, 사회적 민감성, 협상, 설득, 타인을 돕고 돌보기 같은 것들이 요구되는 수준이 높은 직업은 AI가 대체하기 어렵다.</p><ul><li>독창성(Originality): 주어진 주제나 상황에 대해 특이하거나 독창적인 생각을 해내기, 혹은 문제를 해결하는 창의적인 방법들을 만들어 내기.</li><li>사회적 민감성(Social preceptiveness): 타인의 반응을 알아차리고 그 사람들이 왜 그렇게 반응하는지 이해하기.</li><li>협상(Negotiation): 사람들을 화해시키고 서로 간의 차이를 조정하려고 노력하기.</li><li>설득(Persuasion): 다른 사람들의 마음이나 행동을 바꾸게 설득하기.</li><li>타인을 돕고 돌보기(Assisting and caring for others): 개인적 도움, 치료, 감정적 지지, 혹은 동료, 고객, 환자 같은 타인들에 대한 기타의 개인적인 도움을 제공하는 것.</li></ul><p>나는 개발자다. 개발자 분야를 살펴보면 컴퓨터 프로그래머는 AI가 대체하기 쉬운 직업이고 소프트웨어 개발자는 AI가 대체하기 어려운 직업이다. 이 둘의 차이는 독창성, 협상, 설득 능력에 차이가 있다.</p><ul><li>컴퓨터 프로그래머: 다른 사람이 준 스펙대로 개발하는 것을 주 업무로 하며 그 과정에서 협상, 설득이 크게 필요하지 않다.</li><li>소프트웨어 개발자: 소프트웨어를 만들때, 뭘 만들지를 고민하고 설계하는 부분이 포함되며, 그 과정에서 타인과 상호작용하는 업무가 많다.</li></ul><p>이 뿐만아니라 현재 임금이 낮은 직업일수록 AI가 해당 직업을 대체할 가능성이 높다.</p><p>자신의 커리어를 만들 때 AI가 대체 가능한지를 확인해야 한다. AI가 대체 가능한 커리어인 경우, 경쟁력이 없고 어쩌면 직업 자체가 없어질 수 있다. AI 시대에서 살아남기 위해서는 AI가 대체하기 어려운 부분을 학습하고 성장할 수 있도록 노력해야 한다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="essay"/><summary type="html"><![CDATA[AI 시대에서 AI가 대체하기 어려운 커리어를 만들기 위한 학습 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">VSCode Incoming/Outgoing changes graph 숨기기</title><link href="https://deku.posstree.com/ko/environment/vscode/incoming-outgoing-changes-graph" rel="alternate" type="text/html" title="VSCode Incoming/Outgoing changes graph 숨기기"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-16T10:52:53+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-incoming-outgoing-changes-graph-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/incoming-outgoing-changes-graph"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</a></li><li><a href="#incomingoutgoing-changes-graph-%EC%88%A8%EA%B8%B0%EA%B8%B0">Incoming/Outgoing changes graph 숨기기</a></li><li><a href="#%ED%99%95%EC%9D%B8">확인</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>2024년 7월에 업데이트된 Visual Studio Code(VSCode)의 Git 기능 중 하나인 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>는 Git의 History를 그래프로 보여주는 기능입니다.</p><ul><li><a href="https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph" rel="nofollow noreferrer" target="_blank">https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph</a></li></ul><p>이 기능이 추가되면서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열때 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 표시되는 속도가 느려지는 문제가 발생하였습니다.</p><p>이번 블로그 포스트에서는 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널의 속도가 느려지는 문제를 해결하기 위해 VSCode의 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨기는 방법에 대해서 알아보도록 하겠습니다.</p><h2 id="incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</h2><p>VSCode에서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열면 아래와 같이 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>가 보입니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.png" alt="VSCode source control - incoming outgoing changes graph"/></picture><p>이 기능이 추가되면서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열때 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 표시되는 속도가 느려지는 문제가 발생하였습니다.</p><h2 id="incomingoutgoing-changes-graph-숨기기">Incoming/Outgoing changes graph 숨기기</h2><p>다행이도 VSCode에서는 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨길 수 있는 설정이 있습니다.</p><p>VSCode 설정에서 <code class="language-plaintext highlighter-rouge">scm.showHistoryGraph</code>을 검색하면, 다음과 같이 <code class="language-plaintext highlighter-rouge">SCM: Show History Graph</code>을 찾을 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.png" alt="VSCode source control - show history graph setting"/></picture><p>이 설정의 체크를 해제함으로써 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨길 수 있습니다.</p><h2 id="확인">확인</h2><p>이 설정의 체크를 해제하고 다시 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열어보면, <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>가 숨겨진 것을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.png" alt="VSCode source control - hide incoming outgoing changes graph"/></picture><h2 id="완료">완료</h2><p>이것으로 VSCode의 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨기는 방법에 대해서 알아보았습니다. 저처럼 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 느려지는 문제가 발생하였다면, 이 방법을 사용하여 문제를 해결해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[VSCode에 2024년 7월에 새로 추가된 Git의 Incoming/Outgoing changes graph 기능을 숨기는 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">웹 캐시(Web cache)와 AWS S3, CloudFront</title><link href="https://deku.posstree.com/ko/environment/web/cache-and-aws-s3-cloudfront" rel="alternate" type="text/html" title="웹 캐시(Web cache)와 AWS S3, CloudFront"/><published>2024-08-15T00:00:00+09:00</published><updated>2024-08-21T12:10:16+09:00</updated><id>https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD">웹 캐시 탄생 배경</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C">웹 캐시</a><ul><li><a href="#cdncontents-delivery-network">CDNContents Delivery Network</a></li><li><a href="#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%BA%90%EC%8B%9Cbrowser-cache">브라우저 캐시Browser cache</a></li></ul></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D">웹 캐시 동작 방식</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95">웹 캐시 설정</a></li><li><a href="#aws-s3%EC%99%80-cloudfront">AWS S3와 CloudFront</a></li><li><a href="#aws-s3-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95">AWS S3 캐시 설정</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#stale-while-revalidate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC">stale-while-revalidate를 사용한 무중단 배포</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>웹 개발에서 캐시(Cache)는 중요한 역할을 합니다. 캐시를 통해 웹 서비스의 성능을 향상시킬 수 있고, 사용자 경험을 개선할 수 있습니다. 이번 블로그 포스트에서는 웹 개발에서의 캐시(Cache)에 대해서 알아보고, AWS S3에 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아봅시다.</p><h2 id="웹-캐시-탄생-배경">웹 캐시 탄생 배경</h2><p>클라이언트(PC, 스마트폰)에서 서버에 있는 정보를 습득하기 위해서는 인터넷(Internet)을 사용하게 됩니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.png" alt="Web cache and S3 - server and client with internet"/></picture><p>클라이언트와 서버를 연결해주는 인터넷은 물리적으로 연결되어 있으며, 전 세계의 인터넷은 해저 케이블로 연결되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.jpg" alt="Web cache and S3 - internet submarine cable"/></picture><p>클라이언트와 서버는 이렇게 물리적으로 연결이 되어있기 때문에, 당연히 거리가 멀수록 데이터를 주고 받는데 시간이 걸리게 됩니다.</p><h2 id="웹-캐시">웹 캐시</h2><p>웹 캐시는 물리적으로 먼 곳에 있는 서버의 콘텐츠 중 변경이 적은 콘텐츠(정적 콘텐츠: HTML, CSS, JS, Image, Video 등)를 물리적으로 가까운 곳(서버)에 복사하여 배치함으로써 데이터 송수신의 지연을 줄이는 기술입니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" alt="Web cache and S3 - web cache"/></picture><p>웹에서는 크게 세가지 캐시를 사용합니다.</p><ol><li>CDN(Contents Delivery Network)</li><li>브라우저 캐시(Browser cache)</li><li>데이터베이스 캐시(Database cache)</li></ol><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache with browser"/></picture><p>이번 블로그 포스트에서는 CDN과 브라우저 캐시에 대해서 알아보도록 하겠습니다.</p><h3 id="cdncontents-delivery-network">CDN(Contents Delivery Network)</h3><p>CDN은 변경이 적은 콘텐츠의 복사본을 세계의 여러 곳에 있는 서버를 두고 콘텐츠를 제공하는 서비스입니다.</p><p>이를 통해 클라이언트와 서버 간의 거리를 줄여 데이터 송수신의 지연을 줄일 수 있습니다.</p><p>예를 들어, 세계적으로 유명한 CDN 서비스인 <code class="language-plaintext highlighter-rouge">Cloudflare</code>는 다음과 같이 전 세계에 서버를 두고 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.png" alt="Web cache and S3 - cloudflare server list"/></picture><p><code class="language-plaintext highlighter-rouge">Cloudflare</code>를 이용하면 정적 파일을 <code class="language-plaintext highlighter-rouge">Cloudflare</code>가 제공하는 서버에 복사하여 클라이언트와 가까운 서버에서 콘텐츠를 제공할 수 있습니다.</p><h3 id="브라우저-캐시browser-cache">브라우저 캐시(Browser cache)</h3><p>클라이언트 측에서 보면 가장 가까운 서버는 클라이언트 자체입니다. 브라우저는 클라이언트가 한 번 액세스한 사이트에서 일부 콘텐츠를 클라이언트 스토리지에 저장하고 다시 액세스할 때 이 저장된 콘텐츠를 사용하게 하는 브라우저 캐시 기능을 제공합니다.</p><p>Chrome 브라우저의 경우 다음 위치에 캐시를 합니다.</p><ul><li>Windows: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;User Name&gt;\AppData\Local\Google\Chrome\User Data\Default\Cache</code></li><li>macOS: <code class="language-plaintext highlighter-rouge">/Users/&lt;User Name&gt;/Library/Caches/Google/Chrome/Default/Cache</code></li></ul><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="웹-캐시-동작-방식">웹 캐시 동작 방식</h2><p>웹 캐시가 동작하는 방식에 대해서 알아보도록 하겠습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache process"/></picture><ol><li>사용자가 브라우저에서 서비스에 액세스합니다.</li><li>브라우저는 브라우저에 캐시된 것이 있는지 확인하고 캐시가 있는 경우 이를 사용하여 화면에 표시합니다.</li><li>브라우저에 캐시가 없으면 CDN에 캐시가 있는지 확인합니다. CDN에 캐시가 있는 경우 캐시를 사용합니다.</li><li>CDN에 캐시가 없으면 실제 서버에서 콘텐츠를 가져옵니다.</li><li>이때 CDN은 캐시할 필요가 있는지 확인하고 캐시할 수 있는 경우 캐시합니다.</li><li>브라우저도 마찬가지로 캐시할 수 있는 경우 캐시합니다.</li><li>다음부터 사용자가 같은 콘텐츠에 액세스할 때 브라우저와 CDN에서 캐시된 콘텐츠를 사용합니다.</li></ol><h2 id="웹-캐시-설정">웹 캐시 설정</h2><p>브라우저와 CDN은 어떤 기준으로 캐시를 설정할까요? 브라워저와 CDN은 HTTP 응답 헤더에 <code class="language-plaintext highlighter-rouge">Expires</code>, <code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">Etag</code>, <code class="language-plaintext highlighter-rouge">Last-Modified</code> 등을 확인하여 캐시 여부를 결정합니다.</p><p>HTTP 응답 헤더에 캐시는 다음과 같은 방법으로 설정할 수 있습니다.</p><ul><li>Nginx 설정</li></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
    listen 80;
    server_name example.com;

    location / {
        # Set Cache-Control
        add_header Cache-Control "max-age=3600, public";

        # Set Expires
        expires 1h;
    }
}
</code></pre></div></div><ul><li>웹 서버 설정(NodeJS의 Express 예)</li></ul><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Set Cache-Control</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cache-Control</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">max-age=3600, public</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// Set Expires</span>
    <span class="kd">const</span> <span class="nx">maxAgeInSeconds</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="nx">date</span><span class="p">.</span><span class="nx">setSeconds</span><span class="p">(</span><span class="nx">date</span><span class="p">.</span><span class="nx">getSeconds</span><span class="p">()</span> <span class="o">+</span> <span class="nx">seconds</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">expiryDate</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">toUTCString</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Expires</span><span class="dl">'</span><span class="p">,</span> <span class="nx">expiryDate</span><span class="p">);</span>

    <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Server is running on port 3000</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>이렇게 설정된 HTTP 응답 헤더를 확인하여 CDN과 브라우저가 캐시를 설정하게 됩니다.</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="aws-s3와-cloudfront">AWS S3와 CloudFront</h2><p>AWS의 S3와 CloudFront를 사용하여 정적 웹 사이트를 서비스할 수 있습니다.</p><ul><li>S3(Simple Storage Service): 정적 파일을 저장하는 서비스</li><li>CloudFront: CDN 서비스</li></ul><p>S3는 스토리지 서비스이지만 정적 파일로 웹 서비스를 할 수 있는 서버 기능도 제공하고 있습니다.</p><p>일반적으로 HTML, CSS, JavaScript로 개발된 정적 웹 페이지나 React, Vue, Angular 등의 프론트엔드 프레임워크로 개발된 웹 애플리케이션의 빌드 결과물을 S3에 업로드하여 CloudFront를 통해 서비스하게 됩니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.png" alt="Web cache and S3 - AWS S3 and CloudFront cache"/></picture><p>이때, S3에 업로드한 파일 설정으로 통해 브라우저 캐시와 CDN(CloudFront) 캐시를 설정할 수 있습니다.</p><h2 id="aws-s3-캐시-설정">AWS S3 캐시 설정</h2><p>캐시는 HTTP의 응답 헤더에 <code class="language-plaintext highlighter-rouge">Expires</code>나 <code class="language-plaintext highlighter-rouge">Cache-Control</code>을 설정하기 때문에 기본적으로 프론트엔드 측에서 설정할 수 없습니다.</p><p><code class="language-plaintext highlighter-rouge">CloudFront + S3</code>는 서버가 없기 때문에 HTTP 헤더를 설정하는 서버 코드를 추가할 수 없습니다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">S3</code>가 서버 기능을 가지고 있으므로, S3의 설정을 통해 바꾸는 것으로 캐시를 설정하게 됩니다.</p><p>AWS가 제공하는 CLI 툴을 사용하여 S3에 파일을 업로드할 때, 다음과 같은 명령어를 사용합니다. 이때, <code class="language-plaintext highlighter-rouge">--cache-control</code> 옵션을 사용하면 캐시를 설정할 수 있습니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws s3 <span class="nb">cp</span> &lt;Target directory&gt; s3://&lt;S3 Bucket name&gt; <span class="nt">--recursive</span> <span class="nt">--exclude</span> <span class="s2">"assets/*"</span> <span class="nt">--cache-control</span> <span class="s1">'public,max-age=60,stale-while-revalidate=2592000’
</span></code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">Target directory</code>: S3에 업로드할 빌드 결과가 있는 로컬 폴더 경로</li><li><code class="language-plaintext highlighter-rouge">S3 Bucket name</code>: 파일을 업로드할 대상이 되는 S3의 Bucket name</li><li><code class="language-plaintext highlighter-rouge">--recursive</code> 옵션: <code class="language-plaintext highlighter-rouge">aws s3 cp</code>는 기본 파일 하나를 복사하는 명령이므로, 지정된 디렉토리의 모든 파일을 업로드하기 위해 <code class="language-plaintext highlighter-rouge">--recursive</code> 옵션 사용</li><li><code class="language-plaintext highlighter-rouge">--exclude "assets/*"</code>: 업로드 제외 대상 설정</li><li><code class="language-plaintext highlighter-rouge">--cache-control 'public,max-age=60,stale-while-revalidate=2592000'</code>: 캐시 설정</li><li><code class="language-plaintext highlighter-rouge">max-age=60</code>: 60초 동안 캐시</li><li><code class="language-plaintext highlighter-rouge">stale-while-revalidate</code>: <code class="language-plaintext highlighter-rouge">max-age</code>에 의해 캐시가 종료된 경우, 백그라운드에서 콘텐츠를 다시 확인하고 캐시하는 동안, 만료된 캐시를 최대 30일 동안 제공하도록 설정</li></ul><h2 id="github-actions">GitHub Actions</h2><p>다음은 <code class="language-plaintext highlighter-rouge">GitHub Actions</code>를 사용하여 S3에 파일을 업로드하는 코드입니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure AWS credentials</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">aws-actions/configure-aws-credentials@v4</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">role-to-assume</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">aws-region</span><span class="pi">:</span> <span class="s">ap-northeast-1</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload file to S3</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">aws s3 rm s3://$ --recursive</span>
    <span class="s">aws s3 cp apps/dist s3://$ --recursive --exclude "assets/*" --cache-control 'public,max-age=60,stale-while-revalidate=2592000'</span>
    <span class="s">aws s3 sync apps/dist/assets s3://$/assets --cache-control 'public,max-age=60,immutable'</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">aws s3 rm</code>을 사용하여 모든 파일을 삭제한 후, <code class="language-plaintext highlighter-rouge">aws s3 cp</code>를 사용하여 파일을 업로드합니다. 마지막에 <code class="language-plaintext highlighter-rouge">assets</code> 폴더를 <code class="language-plaintext highlighter-rouge">aws s3 sync</code>를 사용하여 업로드합니다.</p><h2 id="stale-while-revalidate를-사용한-무중단-배포">stale-while-revalidate를 사용한 무중단 배포</h2><p>AWS에서 소개된 사용법입니다.</p><ul><li><a href="https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/" rel="nofollow noreferrer" target="_blank">https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/</a></li></ul><p>stale-while-revalidate를 사용하면 중단없이 서비스 버전을 업데이트할 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.png" alt="Web cache and S3 - stale-while-revalidate option for no downtime deployment"/></picture><ol><li>사용자가 브라우저에서 서비스를 실행합니다.</li><li>V1에서 이미 서비스를 이용하고 있는 유저는, 브라우저에 stale-while-revalidate가 설정된 V1의 캐시가 있으므로, 그것을 우선 사용하게 됩니다.</li><li>브라우저는 백그라운드에서 캐시가 종료된(max-age) 콘텐츠를 CloudFront(CDN)에 요청하게 됩니다.</li><li>CloudFront는 V2로 업데이트된 캐시가 있으므로, 그것을 브라우저에 제공합니다.</li><li>브라우저는 CloudFront로부터 전달받은 콘텐츠를 캐시해 다음부터 이것을 사용하게 합니다.</li><li>만약 CloudFront의 캐시도 갱신이 필요한 경우(max-age), 우선은 stale-while-revalidate가 설정된 V1의 캐시를 브라우저에 제공한 후, 백그라운드에서 실제의 서버로부터 콘텐츠를 가져와 자신의 캐시를 갱신합니다.</li></ol><h2 id="완료">완료</h2><p>이것으로 웹 캐시(Web cache)에 대해서 알아보고, AWS S3와 CloudFront를 사용하여 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아보았습니다.</p><p>이 블로그 포스트가 웹 캐시의 이해와 AWS에서 웹 캐시를 적용할때 도움이 되었기를 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[웹 개발에서의 캐시(Cache)에 대해서 알아보고, AWS S3와 CloudFront를 사용하여 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">소프트웨어 개발 배포 전략</title><link href="https://deku.posstree.com/ko/environment/deployment-strategy/" rel="alternate" type="text/html" title="소프트웨어 개발 배포 전략"/><published>2024-08-07T00:00:00+09:00</published><updated>2024-08-09T14:33:57+09:00</updated><id>https://deku.posstree.com/environment/deployment-strategy-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/deployment-strategy/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%8A%A4-%EB%B0%B0%ED%8F%AC">인플레이스 배포</a></li><li><a href="#%EB%A1%A4%EB%A7%81-%EB%B0%B0%ED%8F%AC">롤링 배포</a></li><li><a href="#%EB%B8%94%EB%A3%A8-%EA%B7%B8%EB%A6%B0-%EB%B0%B0%ED%8F%AC">블루 그린 배포</a></li><li><a href="#%EC%B9%B4%EB%82%98%EB%A6%AC-%EB%B0%B0%ED%8F%AC">카나리 배포</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>소프트웨어 개발에서 배포 전략은 서비스를 안정적으로 운영하기 위한 방법입니다. 배포 전략은 다양한 종류가 있으며, 각각의 특징에 따라 적합한 배포 전략을 선택하여 사용해야 합니다. 이번 블로그 포스트에서는 배포 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.</p><h2 id="인플레이스-배포">인플레이스 배포</h2><p>인플레이스 배포(In-place deployment)는 금융기관이나 게임 업데이트처럼 유저에게 통지를 하고 그 시간에 서비스를 멈추고 업데이트하는 구조입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" alt="Deployment strategy - in place deployment"/></picture><ol><li>운영중인 서버를 중지합니다.</li><li>새 애플리케이션을 배포합니다.</li><li>중지된 서버를 다시 시작합니다.</li></ol><p>인플레이스 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>모든 사용자는 항상 동일한 버전의 응용 프로그램을 사용합니다.</li><li>구버전, 신버전이 동시에 존재하지 않기 때문에, 호환성을 생각할 필요가 없고, 호환성을 지원하지 못해 발생하는 문제가 나올 가능성이 없다.</li><li>배포에 관한 인프라 구성이 필요없고, 배포도 간단하기 때문에 비용적으로 저렴하다.</li></ul><p>단점</p><ul><li>서비스를 일시 중지해야 합니다.</li><li>배포가 완료된 후, 문제가 있어 롤백할 필요가 있는 경우, 서비스를 멈춰야함으로 롤백하기 어렵다.</li><li>배포 도중 문제가 발생하면 서비스 중지 시간이 길어질 수 있습니다.</li></ul><p>금융 기관처럼 배포 할 때 이전 버전과 새로운 버전에서 문제가 발생하면 중요한 문제(금전적 문제)가 되는 서비스, 또는 게임처럼 새로운 버전을 사용하지 않으면 새로운 아이템, 지도, 게임 시스템 사용할 수 없는 서비스는 인플레이스 배포 방법을 사용합니다.</p><h2 id="롤링-배포">롤링 배포</h2><p>롤링 배포(Rolling-update Deployment)는 운용할 수 있는 서버 대수가 제한된 경우, 인플레이스 배포와는 달리 중단 없이 배포할 필요가 있는 경우, 사용하는 방법입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" alt="Deployment strategy - rolling update deployment"/></picture><ol><li>현재 운영 중인 서버 중 하나를 외부(사용자)에서 액세스할 수 없도록 합니다.</li><li>액세스가 없는지 확인합니다.</li><li>액세스를 중지한 서버에 새 응용 프로그램을 배포합니다.</li><li>배포된 서버를 외부에서 액세스할 수 있도록 합니다.</li><li>새로 배포한 서버가 외부에서 액세스할 수 있는지 확인합니다.</li><li>모든 서버가 새 버전의 애플리케이션이 될 때까지 1~5를 반복합니다.</li></ol><p>롤링 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>중단 없이 배포할 수 있습니다.</li><li>여러 서버에 배포하기 때문에, 새롭게 배포한 서버에 문제가 발생하면 배포를 중단하거나 롤백할 수 있습니다.</li><li>여러 서버를 최대 이용 가능한 상황에서 배포하기 때문에 부하가 분산된다.</li></ul><p>단점</p><ul><li>서버 대수가 제한되어 있는 상태에서 서버 1대를 정지해 배포를 하기 때문에, 일시적 다른 서버에 부하가 걸릴 가능성이 있다.</li><li>1대씩 배포를 하기 때문에 전부 배포되기까지 상당히 시간이 걸린다.</li><li>구버전과 신버전이 동시에 운용되고 있으므로, 호환성이 있는 어플리케이션을 개발해 배포할 필요가 있다.</li></ul><p>이 배포 방법은 운용 자금에 제한이 있어 서버를 늘릴 수 없는 서비스나 회사에서 사용하며, 중단 없이 서비스를 운용할 때 자주 사용합니다.</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="블루-그린-배포">블루 그린 배포</h2><p>블루 그린 배포(Blue/Green Deployment)는 서버의 제한이 없으며 서비스를 중단없이 배포하고 싶은 경우, 자주 사용하는 방법입니다. 새 버전의 어플리케이션을 프로덕션 환경에서 테스트하려는 경우에도 이 방법을 사용합니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" alt="Deployment strategy - Blue green deployment"/></picture><ol><li>새 버전을 배포하기 위한 서버(Green)를 만듭니다.</li><li>새로 만든 서버에 새 어플리케이션을 배포합니다.</li><li>새로운 액세스는 새로운 서버에 흐르게 하고, 기존의 서버(Blue)에는 새로운 액세스가 접근하지 못하도록 합니다.</li><li>새 서버에 액세스할 때 또는 새 어플리케이션에서 문제가 발생하면 새로운 액세스를 기존 서버로 흐르게 하여 롤백합니다.</li><li>새로운 서버의 액세스가 특별히 문제가 없으면 기존의 서버를 지웁니다.</li></ol><p>블루 그린 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>서비스를 중단 없이 배포할 수 있습니다.</li><li>새 버전을 배포할 때, 이전 버전의 서버가 아직 살아 있기 때문에 문제가 있었을 때 롤백이 빠릅니다.</li><li>새 버전과 이전 버전의 전환이 간단하기 때문에 프로덕션 환경에서 신버전을 테스트할 수 있다.</li></ul><p>단점</p><ul><li>새 버전과 이전 버전의 서버를 준비해야하므로 일시적인 비용이 두 배가 됩니다.</li><li>새 버전이 문제가 없는지 확인하고 이전 버전을 지우므로 배포를 완료하는 데 시간이 걸립니다.</li><li>배포를 완료하고 이전 버전의 서버를 삭제했다면, 롤백을 할 수 없습니다. 이 경우, 롤백하려면 이전 버전을 새로 배포해야 합니다.</li></ul><p>새 버전과 이전 버전이 동시에 존재해도 문제가 없는 서비스로, 배포되는 도중에 기존 액세스를 강제적으로 끊지 않으므로, Session이나 Socket등을 사용하여 사용자의 액세스를 관리하는 서비스에서 사용합니다.</p><h2 id="카나리-배포">카나리 배포</h2><p>카나리 배포(Canary deployment)는 A/B 테스트, 새로운 버전의 기능의 피드백이 필요한 경우, 서비스의 버전 업데이트를 신중하게 하고 싶은 경우, 개발중의 기능을 프로덕션 환경에서 테스트해 보고 싶은 경우에 사용할 수 있는 배포 방법입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/canary.webp" alt="Deployment strategy - Canary deployment"/></picture><ol><li>새 버전을 배포한 서버를 준비합니다.</li><li>서비스 액세스중 일부를 새 버전으로 돌립니다.</li><li>새로운 버전이 좋다고 판단되면 사용자의 액세스를 점진적으로 늘립니다.</li><li>좋지 않다고 판단되면 이전 버전의 서버에 사용자 액세스를 반환합니다.</li><li>모든 액세스가 새 버전의 서버로 돌아가면 이전 버전의 서버를 지웁니다.</li></ol><p>카나리 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>A/B 테스트나 새로운 기능의 반응을 관찰하여 새로운 기능을 도입할지 여부를 결정할 수 있다.</li><li>롤백이 쉽습니다.</li><li>모니터링하면서 배포가 가능하므로 더 안전하게 배포가 가능하다.</li></ul><p>단점</p><ul><li>새 버전과 이전 버전의 서버를 준비해야하므로 일시적인 비용이 두 배가 됩니다.</li><li>새 버전이 문제가 없는지 확인하고 이전 버전을 지우므로 배포를 완료하는 데 시간이 걸립니다.</li><li>서비스를 사용하는 사람에 따라 보는 화면이 다르거나 새로운 기능을 사용할 수 없게 되기 때문에 UX 불일치 문제가 발생할 수 있습니다.</li></ul><p>새로운 기능에 대해 A/B 테스트를 하고 싶은 경우, 사용자의 액세스가 많은 경우, 이 배포 방법을 사용합니다. 또는 개발 중인 기능을 프로덕션의 일부 트래픽을 받게 하여 문제가 없는지 확인할 때도 사용합니다.</p><h2 id="완료">완료</h2><p>이것으로 소프트웨어 개발에서 서비스 배포 전략의 종류와 사용법에 대해서 알아보았습니다. 이 블로그 포스트가 현재 운영중인 서비스와 리소스에 따라 적합한 배포 전략을 선택하는데 도움이 되었으면 좋겠습니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[소프트웨어 개발에서 서비스 배포 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry></feed>