<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://deku.posstree.com/ko/feed.xml" rel="self" type="application/atom+xml"/><link href="https://deku.posstree.com/ko/" rel="alternate" type="text/html"/><updated>2024-09-16T19:30:06+09:00</updated><id>https://deku.posstree.com/feed.xml</id><title type="html">Deku</title><subtitle>『Programming Artist, DeKu』</subtitle><author><name>dev.yakuza@gmail.com</name></author><entry xml:lang="ko"><title type="html">[GitHub Actions] 수동으로 GitHub Actions 실행하기</title><link href="https://deku.posstree.com/ko/github_actions/execute-github-actions-manually/" rel="alternate" type="text/html" title="[GitHub Actions] 수동으로 GitHub Actions 실행하기"/><published>2024-09-13T00:00:00+09:00</published><updated>2024-09-16T16:56:41+09:00</updated><id>https://deku.posstree.com/github_actions/execute-github-actions-manually-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/execute-github-actions-manually/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#workflow_dispatch">workflow_dispatch</a></li><li><a href="#inputs-%ED%83%80%EC%9E%85">inputs 타입</a></li><li><a href="#%EC%98%88%EC%A0%9C">예제</a><ul><li><a href="#boolean">boolean</a></li><li><a href="#choice">choice</a></li><li><a href="#number">number</a></li><li><a href="#string">string</a></li><li><a href="#environment">environment</a></li></ul></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>GitHub Actions를 사용하다보면 수동으로 GitHub Actions를 실행해야 할 때가 있습니다. 이번 블로그 포스트에서는 GitHub Actions를 수동으로 실행하는 방법에 대해서 알아보겠습니다.</p><h2 id="workflow_dispatch">workflow_dispatch</h2><p><code class="language-plaintext highlighter-rouge">GitHub Actions</code>를 수동으로 실행하기 위해서는 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>를 사용해야 합니다.</p><ul><li>공식 문서: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch</a></li></ul><p>이때, <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>을 통해 파라미터를 전달할 수 있습니다.</p><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>는 다음과 같이 설정할 수 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
</code></pre></div></div><h2 id="inputs-타입">inputs 타입</h2><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>에는 다음과 같은 종류가 있습니다.</p><ul><li><code class="language-plaintext highlighter-rouge">boolean</code>: true 또는 false</li><li><code class="language-plaintext highlighter-rouge">choice</code>: 미리 지정된 옵션 중 하나를 선택할 수 있는 SelectBox</li><li><code class="language-plaintext highlighter-rouge">number</code>: 숫자</li><li><code class="language-plaintext highlighter-rouge">string</code>: 문자열</li><li><code class="language-plaintext highlighter-rouge">environment</code>: GitHub에 설정한 환경 변수 사용</li></ul><p>공식 문서에서도 사용 가능한 <code class="language-plaintext highlighter-rouge">inputs</code> 타입을 확인할 수 있습니다.</p><ul><li>공식 문서: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype</a></li></ul><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 <code class="language-plaintext highlighter-rouge">inputs</code>은 다음과 같이 설정할 수 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">inputs</code>은 <code class="language-plaintext highlighter-rouge">type</code>이외에도 <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">required</code>, <code class="language-plaintext highlighter-rouge">default</code>를 설정할 수 있습니다. <code class="language-plaintext highlighter-rouge">type</code>이외에는 모두 선택 사항입니다.</p><h2 id="예제">예제</h2><p>그럼 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>를 사용하여 GitHub Actions를 수동으로 실행하는 예제를 살펴보겠습니다.</p><h3 id="boolean">boolean</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.png" alt="Execute GitHub Actions manually - Boolean input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">boolean</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.png" alt="Execute GitHub Actions manually - Boolean input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="choice">choice</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_choice</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">choice</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">warning'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">choice</span>
        <span class="na">options</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s">info</span>
          <span class="pi">-</span> <span class="s">warning</span>
          <span class="pi">-</span> <span class="s">debug</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.png" alt="Execute GitHub Actions manually - Choice input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">choice</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.png" alt="Execute GitHub Actions manually - Choice input result"/></picture><h3 id="number">number</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_number</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">number</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="m">20</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">number</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input.png" alt="Execute GitHub Actions manually - Number input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">number</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.png" alt="Execute GitHub Actions manually - Number input result"/></picture><h3 id="string">string</h3><p>수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_string</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">string</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Hello,</span><span class="nv"> </span><span class="s">World!'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">string</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input.png" alt="Execute GitHub Actions manually - String input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 우리가 설정한 <code class="language-plaintext highlighter-rouge">string</code> 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>를 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.png" alt="Execute GitHub Actions manually - String input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="environment">environment</h3><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>의 에서 <code class="language-plaintext highlighter-rouge">environment</code> 타입을 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Settings</code>에서 <code class="language-plaintext highlighter-rouge">Environment</code>를 설정해야 합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environments.png" alt="Execute GitHub Actions manually - Environments"/></picture><p><code class="language-plaintext highlighter-rouge">New environment</code>를 클릭하고 다음과 같이 <code class="language-plaintext highlighter-rouge">Name</code>에 <code class="language-plaintext highlighter-rouge">dev</code>를 입력한 후, <code class="language-plaintext highlighter-rouge">Configure environment</code>를 클릭합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.png" alt="Execute GitHub Actions manually - New Dev Environment"/></picture><p>그런 다음 <code class="language-plaintext highlighter-rouge">Environment variables</code>의 <code class="language-plaintext highlighter-rouge">Add environment variable</code> 버튼을 누르고 다음과 같이 <code class="language-plaintext highlighter-rouge">Variable</code>을 추가합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.png" alt="Execute GitHub Actions manually - Dev environment variable"/></picture><p>동일한 방식으로 <code class="language-plaintext highlighter-rouge">prod</code>라는 환경에도 동일한 변수를 추가합니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.png" alt="Execute GitHub Actions manually - Prod environment variable"/></picture><p>이제 수동으로 실행하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_environment</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">environment</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">environment</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">environment</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>이렇게 작성한 파일을 commit하고 push한 후, <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Actions</code> 탭으로 이동하면 다음과 같은 화면을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.png" alt="Execute GitHub Actions manually - Environment input"/></picture><p>오른쪽에 표시된 <code class="language-plaintext highlighter-rouge">Run workflow</code>를 클릭하면 <code class="language-plaintext highlighter-rouge">GitHub</code>의 <code class="language-plaintext highlighter-rouge">Settings</code>에서 <code class="language-plaintext highlighter-rouge">Environment</code>에 설정한 값이 표시되는 것을 확인할 수 있습니다. 이를 실행하면 다음과 같은 결과를 얻을 수 있습니다.</p><ul><li>dev 환경</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.png" alt="Execute GitHub Actions manually - Environment input result dev"/></picture><ul><li>prod 환경</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.png" alt="Execute GitHub Actions manually - Environment input result prod"/></picture><h2 id="완료">완료</h2><p>이것으로 GitHub Actions를 수동으로 실행하는 방법에 대해서 알아보았습니다. 또한 설정 가능한 <code class="language-plaintext highlighter-rouge">inputs</code> 타입에 대해서도 알아보았습니다.</p><p>여러분도 <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>와 다양한 타입의 <code class="language-plaintext highlighter-rouge">inputs</code>을 사용하여 GitHub Actions를 수동으로 실행해보세요.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[수동으로 GitHub Actions를 실행하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] 모노레포 환경에서 GitHub Actions로 PR 제목 검사하는 방법</title><link href="https://deku.posstree.com/ko/github_actions/action-check-pr-title/" rel="alternate" type="text/html" title="[GitHub Actions] 모노레포 환경에서 GitHub Actions로 PR 제목 검사하는 방법"/><published>2024-09-10T00:00:00+09:00</published><updated>2024-09-12T09:04:12+09:00</updated><id>https://deku.posstree.com/github_actions/action-check-pr-title-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/action-check-pr-title/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#action-check-pr-title">action-check-pr-title</a></li><li><a href="#github-actions-%EC%83%9D%EC%84%B1">GitHub Actions 생성</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>저는 <code class="language-plaintext highlighter-rouge">Release Drafter</code>를 사용하여 GitHub의 Release Note를 자동화하고 있습니다.</p><ul><li><a href="https://deku.posstree.com/ko/share/github-actions/release-drafter/" target="\_blank">[GitHub Actions] Release notes 자동화</a></li></ul><p>이 <code class="language-plaintext highlighter-rouge">Release Drafter</code>는 GitHub의 PR의 Label을 기준으로 동작합니다. <code class="language-plaintext highlighter-rouge">Release Drafter</code>는 Label을 자동으로 생성하는 기능을 제공하는데, 이때 PR의 제목을 사용합니다. 그래서 PR의 제목이 중요합니다.</p><p>기존에는 PR의 제목을 검사할 때, <a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>을 사용했습니다.</p><ul><li><a href="https://deku.posstree.com/ko/share/github-actions/pr-title-checker/" target="\_blank">[GitHub Actions] Pull request 제목 검사</a></li></ul><p>하지만 현재 모노레포 프로젝트에서는 해당 <code class="language-plaintext highlighter-rouge">Conventional PR Title Action</code>으로만은 충분하지 않아서 다른 GitHub Actions를 사용하게 되었습니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/repository_strategy/" target="\_blank">[프로젝트 관리] 리포지토리 전략</a></li></ul><p>이번 블로그 포스트에서는 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR을 생성했을 때, PR의 제목을 검사하는 방법에 대해서 알아보겠습니다.</p><h2 id="action-check-pr-title">action-check-pr-title</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>는 정규식을 사용하여 PR의 제목을 검사하는 GitHub Actions입니다.</p><ul><li><a href="https://github.com/Slashgear/action-check-pr-title" rel="nofollow noreferrer" target="\_blank">action-check-pr-title</a></li></ul><h2 id="github-actions-생성">GitHub Actions 생성</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR의 제목을 검사하는 GitHub Actions를 생성하기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/check_pr_title.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
      <span class="pi">-</span> <span class="s">reopened</span>
      <span class="pi">-</span> <span class="s">edited</span>
      <span class="pi">-</span> <span class="s">synchronize</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-pr-title</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Pull Request</code>의 제목을 검사하는 부분을 좀 더 자세히 살펴보겠습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>이 제공하는 <code class="language-plaintext highlighter-rouge">regexp</code>옵션을 사용하여 <code class="language-plaintext highlighter-rouge">PR</code>의 제목을 검사합니다. 여기서 사용하는 정규식은 다음과 같은 PR 제목을 허용합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feat<span class="o">(</span>SERVICE1<span class="o">)</span>: Add new feature
fix<span class="o">(</span>SERVICE2<span class="o">)</span>: Fix bug
refactor<span class="o">(</span>common<span class="o">)</span>: Refactor code
...
</code></pre></div></div><p>모노레포를 사용하기 때문에 <code class="language-plaintext highlighter-rouge">Conventional Commits</code>의 <code class="language-plaintext highlighter-rouge">Scope</code> 영역에 서비스명을 설정하고, 이를 검사하도록 설정했습니다.</p><ul><li><a href="https://www.conventionalcommits.org/en/v1.0.0/" rel="nofollow noreferrer" target="\_blank">Conventional Commits</a></li></ul><h2 id="완료">완료</h2><p>이것으로 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하여 PR을 생성했을 때, PR의 제목을 검사하는 방법에 대해서 알아보았습니다. 기존에 사용하던 <a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>으로도 정규식 검사가 가능하지만, 설정이 간단하지 않아서 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용하게 되었습니다.</p><p>여러분도 간단하게 정규식으로 PR 제목을 검사하고 싶다면 <code class="language-plaintext highlighter-rouge">action-check-pr-title</code>을 사용해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[모노레포 환경에서 GitHub Actions를 사용하여 PR을 생성했을 때, PR(Pull Request)의 제목을 검사하는 방법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] GitHub Actions로 브랜치 이름을 검사하는 방법</title><link href="https://deku.posstree.com/ko/github_actions/check-branch-name" rel="alternate" type="text/html" title="[GitHub Actions] GitHub Actions로 브랜치 이름을 검사하는 방법"/><published>2024-09-02T00:00:00+09:00</published><updated>2024-09-09T09:52:51+09:00</updated><id>https://deku.posstree.com/github_actions/check-branch-name-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/check-branch-name"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%9D%B4%EB%A6%84-%EB%B3%80%EA%B2%BD">브랜치 이름 변경</a></li><li><a href="#git-hooks">Git hooks</a><ul><li><a href="#%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%9D%B4%EB%A6%84-%EA%B2%80%EC%82%AC-script-%EC%83%9D%EC%84%B1">브랜치 이름 검사 script 생성</a></li><li><a href="#husky-%EC%84%A4%EC%A0%95">Husky 설정</a></li><li><a href="#lefthook-%EC%84%A4%EC%A0%95">Lefthook 설정</a></li></ul></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>Git을 사용하여 프로젝트를 개발할 때, 다음 링크와 같이 브랜치 전략을 사용하게 됩니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/branch-strategy/" target="\_blank">소프트웨어 개발을 위한 브랜치 전략</a></li></ul><p>이때 브랜치 전략에 맞게 브랜치를 만들고 있는지 관리가 필요할 때가 있습니다.</p><p>이번 블로그 포스트에서는 GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보도록 하겠습니다.</p><h2 id="github-actions">GitHub Actions</h2><p>브랜치 이름을 검사하는 GitHub Actions를 생성하기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/check-branch-name.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-branch-name</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
</code></pre></div></div><p>이 GitHub Actions를 좀 더 자세히 살펴보도록 하겠습니다.</p><p>저는 모노레포로 프로젝트를 관리하고 있습니다.</p><ul><li><a href="https://deku.posstree.com/ko/environment/repository_strategy/" target="\_blank">[프로젝트 관리] 리포지토리 전략</a></li></ul><p>그래서 다음과 같은 브랜치 이름을 사용하고 있습니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature/:SERVICE_NAME/:BRANCH_NAME
release/:SERVICE_NAME/:BRANCH_NAME
fix/:SERVICE_NAME/:BRANCH_NAME
...
</code></pre></div></div><p>이때 브랜치명이 <code class="language-plaintext highlighter-rouge">dependabot</code>, <code class="language-plaintext highlighter-rouge">hotfix</code><code class="language-plaintext highlighter-rouge">release</code>, <code class="language-plaintext highlighter-rouge">review</code>, <code class="language-plaintext highlighter-rouge">feature</code>, <code class="language-plaintext highlighter-rouge">fix</code>, <code class="language-plaintext highlighter-rouge">sub-feature</code> 등으로 시작하는지 확인하고 <code class="language-plaintext highlighter-rouge">SERVICE_NAME</code>을 추출하여 미리 정의한 이름을 사용하는지 확인하고 있습니다.</p><p>그래서 다음과 같이 서비스명과 브랜치명을 미리 추출하여 환경 변수에 저장하였습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
<span class="s">...</span>
</code></pre></div></div><p>이렇게 추출한 브랜치명과 서비스명을 미리 정의한 값과 비교하여 브랜치명과 서비스명이 유효한지 확인하고 있습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
<span class="s">...</span>
</code></pre></div></div><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="브랜치-이름-변경">브랜치 이름 변경</h2><p>이 GitHub Actions를 사용하면 미리 정의된 규칙에 맞지 않는 브랜치명으로 PR을 생성하면 에러가 발생하게 됩니다. 이때는 다음과 같이 브랜치명을 변경하면 됩니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;current-branch-name&gt;
git branch <span class="nt">-m</span> &lt;new-branch-name&gt;
</code></pre></div></div><p>또는 다음과 같이 변경이 가능합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-m</span> &lt;current-branch-name&gt; &lt;new-branch-name&gt;
</code></pre></div></div><p>이렇게 브랜치명을 변경하였다면 새로운 PR을 생성하고 기존 PR은 닫아주시면 됩니다.</p><h2 id="git-hooks">Git hooks</h2><p>잘못된 브랜치명을 사용한 경우, 이 GitHub Actions로 검사가 가능하지만, PR을 생성하지 않으면 검사가 불가능합니다. 또한, 브랜치명이 잘못된 경우 기존 PR을 닫고 새로운 PR을 생성해야 합니다.</p><p>이때 Git hooks를 사용하면 PR을 생성하기 전에 미리 브랜치명을 검사하면 불필요한 작업을 줄일 수 있습니다.</p><h3 id="브랜치-이름-검사-script-생성">브랜치 이름 검사 script 생성</h3><p>브랜치 이름을 검사하는 script를 생성하기 위해 <code class="language-plaintext highlighter-rouge">scripts/check-branch-name.sh</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

<span class="nv">pattern</span><span class="o">=</span><span class="s1">'^(dependabot|hotfix|release|review|feature|fix|sub-feature)/(npm_and_yarn|github_actions|SERVICE_1|SERVICE_2|template|components|config|common)/.*'</span>
<span class="nv">errorMessage</span><span class="o">=</span><span class="s1">'Invalid branch name. Please follow the correct naming convention.'</span>

<span class="k">if</span> <span class="o">!</span> git rev-parse <span class="nt">--is-inside-work-tree</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Error: Not inside Git working tree."</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">branches</span><span class="o">=</span><span class="si">$(</span>git branch | <span class="nb">grep</span> <span class="s1">'^\*'</span> | <span class="nb">sed</span> <span class="s1">'s/^\* //'</span><span class="si">)</span>

<span class="k">if </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-Eq</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[32mPassed</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
<span class="k">else
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[31mResult: failed</span><span class="se">\n</span><span class="s2">Error Msg: %s</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>
</code></pre></div></div><h3 id="husky-설정">Husky 설정</h3><p>Husky를 사용하여 Git hooks를 설정하려면 다음과 같이 <code class="language-plaintext highlighter-rouge">.husky/pre-commit</code> 파일을 수정합니다.</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">validation</span><span class="w"> </span><span class="err">branch</span><span class="w"> </span><span class="err">name</span><span class="w">
</span><span class="err">.</span><span class="w"> </span><span class="s2">"$(dirname -- "</span><span class="err">$</span><span class="mi">0</span><span class="s2">")/scripts/validateBranchName.sh"</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span><span class="err">yarn</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span></code></pre></div></div><p>이때 앞서 만든 <code class="language-plaintext highlighter-rouge">check-branch-name.sh</code> 파일은 <code class="language-plaintext highlighter-rouge">.husky/scripts/validateBranchName.sh</code>에 이동시켜야 합니다.</p><h3 id="lefthook-설정">Lefthook 설정</h3><p>Lefthook를 사용하여 Git hooks를 설정하려면 다음과 같이 <code class="language-plaintext highlighter-rouge">.lefthook.yml</code> 파일을 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pre-push</span><span class="pi">:</span>
  <span class="na">scripts</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">validateBranchName.sh"</span><span class="err">:</span>
      <span class="na">runner</span><span class="pi">:</span> <span class="s">bash</span>
</code></pre></div></div><p>이때 앞서 만든 <code class="language-plaintext highlighter-rouge">check-branch-name.sh</code> 파일은 <code class="language-plaintext highlighter-rouge">.lefthook/pre-commit/validateBranchName.sh</code>에 이동시켜야 합니다.</p><h2 id="완료">완료</h2><p>이것으로 GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보았습니다. 또한 Git hooks를 사용하여 PR을 생성하기 전에 브랜치명을 검사하는 방법에 대해서도 알아보았습니다.</p><p>만약 저처럼 프로젝트에서 브랜치명이 중요한 역할을 한다면 이 GitHub Actions와 Git Hooks를 사용하여 브랜치명을 검사해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actions를 사용하여 PR을 생성했을 때, 브랜치 이름을 검사하는 방법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[GitHub Actions] PR에 자동으로 Assignees 추가하기</title><link href="https://deku.posstree.com/ko/github_actions/auto-assing-assigness" rel="alternate" type="text/html" title="[GitHub Actions] PR에 자동으로 Assignees 추가하기"/><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-30T09:57:08+09:00</updated><id>https://deku.posstree.com/github_actions/auto-assing-assigness-ko</id><content type="html" xml:base="https://deku.posstree.com/github_actions/auto-assing-assigness"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#github-actions-%EC%83%9D%EC%84%B1">GitHub Actions 생성</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>보통 개발을 완료한 후, 개발을 담당한 개발자가 GitHub에서 PR(Pull Request)을 생성하고, 자기 자신을 <code class="language-plaintext highlighter-rouge">Assignees</code>에 추가합니다. 하지만, 매번 PR을 생성할 때마다 <code class="language-plaintext highlighter-rouge">Assignees</code>에 자기 자신을 추가하는 것은 번거롭습니다.</p><p>이번 블로그 포스트에서는 GitHub Actions를 사용하여 PR을 생성할 때마다 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>에 PR을 생성하는 개발자를 추가하는 방법에 대해서 알아보겠습니다.</p><h2 id="github-actions-생성">GitHub Actions 생성</h2><p>PR에 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>를 추가하는 GitHub Actions를 만들기 위해 <code class="language-plaintext highlighter-rouge">.github/workflows/auto-assign-assignees.yml</code> 파일을 생성하고 다음과 같이 수정합니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Assign assignees</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p>이 GitHub Actions를 좀 더 자세히 살펴보도록 하겠습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
<span class="nn">...</span>
</code></pre></div></div><p>이 GitHub Actions은 PR이 생성될 때 실행됩니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">if</span><span class="err">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="s">...</span>
</code></pre></div></div><p>저는 GitHub에서 Dependabot을 사용하고 있습니다. Dependabot이 생성한 PR의 Assignees에 Dependabot을 추가할 수 없으므로, Dependabot이 생성한 PR에는 Assignees를 추가하지 않도록 설정했습니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">steps</span><span class="err">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">GitHub</code>이 제공하는 GitHub Actions을 사용하여 JavaScript 코드로 PR을 생성하는 개발자(<code class="language-plaintext highlighter-rouge">context.actor</code>)를 <code class="language-plaintext highlighter-rouge">Assignees</code>에 추가하는 코드를 작성했습니다.</p><h2 id="완료">완료</h2><p>이것으로 PR을 생성할 때마다 자동으로 <code class="language-plaintext highlighter-rouge">Assignees</code>에 PR을 생성하는 개발자를 추가하는 GitHub Actions를 만드는 방법에 대해서 알아보았습니다. 여러분도 이 GitHub Actions를 사용하여 수동으로 설정하던 Assignees를 자동으로 설정해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actions를 사용하여 PR에 자동으로 Assignees를 추가하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">VSCode에서 Monorepo를 위한 ESLint 설정하기</title><link href="https://deku.posstree.com/ko/environment/vscode/eslint-configuration-for-monorepo" rel="alternate" type="text/html" title="VSCode에서 Monorepo를 위한 ESLint 설정하기"/><published>2024-08-22T00:00:00+09:00</published><updated>2024-08-27T20:01:47+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-eslint-configuration-for-monorepo-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/eslint-configuration-for-monorepo"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#vscode%EC%9D%98-current-working-directory">VSCode의 Current working directory</a></li><li><a href="#vscodesettingsjson-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95">vscode/settings.json 파일 수정</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>Monorepo 환경에서는 여러 패키지를 하나의 리포지토리에 관리하기 때문에, 각 패키지마다 개별적인 ESLint 설정이 필요할 때가 있습니다. 이때 ESLint가 어느 디렉터리를 기준으로 작동할지 결정하는 것이 중요합니다.</p><p>이번 블로그 포스트에서는 Visual Studio Code(VSCode)에서 Monorepo 프로젝트에서 ESLint의 Current Working Directory(CWD)를 설정하는 방법을 알아보겠습니다.</p><h2 id="vscode의-current-working-directory">VSCode의 Current working directory</h2><p>VSCode에서 특별한 설정을 하지 않는다면, ESLint는 루트 폴더에 있는 ESLint 설정 파일을 기준으로 동작합니다. 하지만, Monorepo 프로젝트에서는 각각의 프로젝트마다 ESLint 설정 파일이 있을 수 있습니다.</p><p>이때, VSCode에서 ESLint의 Current Working Directory(CWD)를 설정하면, ESLint가 해당 디렉터리를 기준으로 동작하게 됩니다.</p><h2 id="vscodesettingsjson-파일-수정">.vscode/settings.json 파일 수정</h2><p>다음은 VSCode에서 ESLint의 Current Working Directory(CWD)를 설정하는 방법입니다.</p><ol><li>mode 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"auto"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>이렇게 설정하면, VSCode는 ESLint 설정 파일이 있는 디렉터리를 자동으로 찾아서 CWD로 설정합니다.</p><ol><li>pattern 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"./packages/*/"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Glob</code> 패턴으로 CWD가 될 디렉터리를 설정할 수도 있습니다.</p><ol><li>디렉토리 지정 설정</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"./packages/package1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"./packages/package2"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>이와 같이 배열로 특정 디렉터리를 지정할 수도 있습니다.</p><h2 id="완료">완료</h2><p>이것으로 VSCode에서 Monorepo 프로젝트를 개발할 떄, ESLint의 Current Working Directory(CWD)를 설정하는 방법에 대해서 알아보았습니다.</p><p>저는 <code class="language-plaintext highlighter-rouge">"mode": "auto"</code>를 설정하여 사용하고 있습니다. 특별한 문제가 없다면 이 설정을 사용하는 것을 추천합니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[Monorepo 프로젝트를 개발할 때, VSCode에서 ESLint를 설정하는 방법에 대해서 알아보겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">VSCode Incoming/Outgoing changes graph 숨기기</title><link href="https://deku.posstree.com/ko/environment/vscode/incoming-outgoing-changes-graph" rel="alternate" type="text/html" title="VSCode Incoming/Outgoing changes graph 숨기기"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-16T10:52:53+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-incoming-outgoing-changes-graph-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/incoming-outgoing-changes-graph"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</a></li><li><a href="#incomingoutgoing-changes-graph-%EC%88%A8%EA%B8%B0%EA%B8%B0">Incoming/Outgoing changes graph 숨기기</a></li><li><a href="#%ED%99%95%EC%9D%B8">확인</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>2024년 7월에 업데이트된 Visual Studio Code(VSCode)의 Git 기능 중 하나인 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>는 Git의 History를 그래프로 보여주는 기능입니다.</p><ul><li><a href="https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph" rel="nofollow noreferrer" target="_blank">https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph</a></li></ul><p>이 기능이 추가되면서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열때 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 표시되는 속도가 느려지는 문제가 발생하였습니다.</p><p>이번 블로그 포스트에서는 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널의 속도가 느려지는 문제를 해결하기 위해 VSCode의 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨기는 방법에 대해서 알아보도록 하겠습니다.</p><h2 id="incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</h2><p>VSCode에서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열면 아래와 같이 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>가 보입니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.png" alt="VSCode source control - incoming outgoing changes graph"/></picture><p>이 기능이 추가되면서 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열때 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 표시되는 속도가 느려지는 문제가 발생하였습니다.</p><h2 id="incomingoutgoing-changes-graph-숨기기">Incoming/Outgoing changes graph 숨기기</h2><p>다행이도 VSCode에서는 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨길 수 있는 설정이 있습니다.</p><p>VSCode 설정에서 <code class="language-plaintext highlighter-rouge">scm.showHistoryGraph</code>을 검색하면, 다음과 같이 <code class="language-plaintext highlighter-rouge">SCM: Show History Graph</code>을 찾을 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.png" alt="VSCode source control - show history graph setting"/></picture><p>이 설정의 체크를 해제함으로써 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨길 수 있습니다.</p><h2 id="확인">확인</h2><p>이 설정의 체크를 해제하고 다시 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널을 열어보면, <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>가 숨겨진 것을 확인할 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.png" alt="VSCode source control - hide incoming outgoing changes graph"/></picture><h2 id="완료">완료</h2><p>이것으로 VSCode의 <code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>를 숨기는 방법에 대해서 알아보았습니다. 저처럼 <code class="language-plaintext highlighter-rouge">Source Control</code> 패널이 느려지는 문제가 발생하였다면, 이 방법을 사용하여 문제를 해결해 보시기 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[VSCode에 2024년 7월에 새로 추가된 Git의 Incoming/Outgoing changes graph 기능을 숨기는 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">[에세이] AI 시대에서 살아 남기 위한 학습 방법</title><link href="https://deku.posstree.com/ko/essay/how-to-survive-in-ai-era/" rel="alternate" type="text/html" title="[에세이] AI 시대에서 살아 남기 위한 학습 방법"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-25T20:50:59+09:00</updated><id>https://deku.posstree.com/essay/how-to-survive-in-ai-era-ko</id><content type="html" xml:base="https://deku.posstree.com/essay/how-to-survive-in-ai-era/"><![CDATA[<p>다음과 같은 조건은 AI가 학습하기 쉬운 조건이다.</p><ol><li>목표(Goal)가 분명하고 객관적이며 정적이다.</li><li>매 순간 선택할 수 있는 행동과 선택의 종류가 유한하다.</li><li>매 순간 자신의 선택에 의해 목표에 얼마나 근접했는지를 알 수 있다.</li><li>주로 예상 못 한 외부 요소의 영향이 없는 닫힌 시스템이다.</li><li>목표 도달을 위한 선택과 결과에 대한 자료가 많다.</li></ol><p>이런 상황은 AI뿐만 아니라 인간도 학습하기 좋은 조건이다.</p><p>제임스 샨토(James Shanteau)가 발표한 <a href="https://www.researchgate.net/publication/4815960_Competence_in_Experts_The_Role_of_Task_Characteristics" rel="nofollow noreferrer" target="_blank">Competence in Experts: The Role of Task Characteristics</a> 연구에 따르면, 피드백이 주어지고 작업이 반복되며 객관적 분석이 가능한 경우에 해당 직업에서 전문성이 잘 드러난다고 한다.</p><p>그러나 이런 전문성이 잘 들어나는 직업이 현재는 AI가 학습하기 좋은 조건을 가졌다고 볼 수 있다.</p><p>인간이 학습하기 쉬운 환경은 AI도 학습하기 쉬운 환경이므로 이런 일은 언젠가 AI에게 자리를 내줘야 할지 모른다. 그러므로 AI 시대에서 살아남기 위해서는 학습하기 힘든 환경에서 학습하기 힘든 주제를 골라야 한다.</p><p>학습하기 힘든 조건은 다음과 같다.</p><ol><li>목표가 모호하고 주관적이며 동적이다.</li><li>매 순간 선택할 수 있는 행동과 선택 종류가 무한하다.</li><li>매 순간 자신의 선택에 의해 목표에 얼마나 근접했는지를 알 수 없다.</li><li>주로 예상 못 한 외부 요소에 영향을 받는 열린 시스템이다.</li><li>목표 도달을 위한 선택과 결과에 대한 자료가 부족하다.</li></ol><p>이런 조건은 인간이 학습하기 어렵고, 특히 AI가 학습하기에는 더 어렵다.</p><p>또한 독창성, 사회적 민감성, 협상, 설득, 타인을 돕고 돌보기 같은 것들이 요구되는 수준이 높은 직업은 AI가 대체하기 어렵다.</p><ul><li>독창성(Originality): 주어진 주제나 상황에 대해 특이하거나 독창적인 생각을 해내기, 혹은 문제를 해결하는 창의적인 방법들을 만들어 내기.</li><li>사회적 민감성(Social preceptiveness): 타인의 반응을 알아차리고 그 사람들이 왜 그렇게 반응하는지 이해하기.</li><li>협상(Negotiation): 사람들을 화해시키고 서로 간의 차이를 조정하려고 노력하기.</li><li>설득(Persuasion): 다른 사람들의 마음이나 행동을 바꾸게 설득하기.</li><li>타인을 돕고 돌보기(Assisting and caring for others): 개인적 도움, 치료, 감정적 지지, 혹은 동료, 고객, 환자 같은 타인들에 대한 기타의 개인적인 도움을 제공하는 것.</li></ul><p>나는 개발자다. 개발자 분야를 살펴보면 컴퓨터 프로그래머는 AI가 대체하기 쉬운 직업이고 소프트웨어 개발자는 AI가 대체하기 어려운 직업이다. 이 둘의 차이는 독창성, 협상, 설득 능력에 차이가 있다.</p><ul><li>컴퓨터 프로그래머: 다른 사람이 준 스펙대로 개발하는 것을 주 업무로 하며 그 과정에서 협상, 설득이 크게 필요하지 않다.</li><li>소프트웨어 개발자: 소프트웨어를 만들때, 뭘 만들지를 고민하고 설계하는 부분이 포함되며, 그 과정에서 타인과 상호작용하는 업무가 많다.</li></ul><p>이 뿐만아니라 현재 임금이 낮은 직업일수록 AI가 해당 직업을 대체할 가능성이 높다.</p><p>자신의 커리어를 만들 때 AI가 대체 가능한지를 확인해야 한다. AI가 대체 가능한 커리어인 경우, 경쟁력이 없고 어쩌면 직업 자체가 없어질 수 있다. AI 시대에서 살아남기 위해서는 AI가 대체하기 어려운 부분을 학습하고 성장할 수 있도록 노력해야 한다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="essay"/><summary type="html"><![CDATA[AI 시대에서 AI가 대체하기 어려운 커리어를 만들기 위한 학습 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">웹 캐시(Web cache)와 AWS S3, CloudFront</title><link href="https://deku.posstree.com/ko/environment/web/cache-and-aws-s3-cloudfront" rel="alternate" type="text/html" title="웹 캐시(Web cache)와 AWS S3, CloudFront"/><published>2024-08-15T00:00:00+09:00</published><updated>2024-08-21T12:10:16+09:00</updated><id>https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD">웹 캐시 탄생 배경</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C">웹 캐시</a><ul><li><a href="#cdncontents-delivery-network">CDNContents Delivery Network</a></li><li><a href="#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%BA%90%EC%8B%9Cbrowser-cache">브라우저 캐시Browser cache</a></li></ul></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D">웹 캐시 동작 방식</a></li><li><a href="#%EC%9B%B9-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95">웹 캐시 설정</a></li><li><a href="#aws-s3%EC%99%80-cloudfront">AWS S3와 CloudFront</a></li><li><a href="#aws-s3-%EC%BA%90%EC%8B%9C-%EC%84%A4%EC%A0%95">AWS S3 캐시 설정</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#stale-while-revalidate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC">stale-while-revalidate를 사용한 무중단 배포</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>웹 개발에서 캐시(Cache)는 중요한 역할을 합니다. 캐시를 통해 웹 서비스의 성능을 향상시킬 수 있고, 사용자 경험을 개선할 수 있습니다. 이번 블로그 포스트에서는 웹 개발에서의 캐시(Cache)에 대해서 알아보고, AWS S3에 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아봅시다.</p><h2 id="웹-캐시-탄생-배경">웹 캐시 탄생 배경</h2><p>클라이언트(PC, 스마트폰)에서 서버에 있는 정보를 습득하기 위해서는 인터넷(Internet)을 사용하게 됩니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.png" alt="Web cache and S3 - server and client with internet"/></picture><p>클라이언트와 서버를 연결해주는 인터넷은 물리적으로 연결되어 있으며, 전 세계의 인터넷은 해저 케이블로 연결되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.jpg" alt="Web cache and S3 - internet submarine cable"/></picture><p>클라이언트와 서버는 이렇게 물리적으로 연결이 되어있기 때문에, 당연히 거리가 멀수록 데이터를 주고 받는데 시간이 걸리게 됩니다.</p><h2 id="웹-캐시">웹 캐시</h2><p>웹 캐시는 물리적으로 먼 곳에 있는 서버의 콘텐츠 중 변경이 적은 콘텐츠(정적 콘텐츠: HTML, CSS, JS, Image, Video 등)를 물리적으로 가까운 곳(서버)에 복사하여 배치함으로써 데이터 송수신의 지연을 줄이는 기술입니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" alt="Web cache and S3 - web cache"/></picture><p>웹에서는 크게 세가지 캐시를 사용합니다.</p><ol><li>CDN(Contents Delivery Network)</li><li>브라우저 캐시(Browser cache)</li><li>데이터베이스 캐시(Database cache)</li></ol><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache with browser"/></picture><p>이번 블로그 포스트에서는 CDN과 브라우저 캐시에 대해서 알아보도록 하겠습니다.</p><h3 id="cdncontents-delivery-network">CDN(Contents Delivery Network)</h3><p>CDN은 변경이 적은 콘텐츠의 복사본을 세계의 여러 곳에 있는 서버를 두고 콘텐츠를 제공하는 서비스입니다.</p><p>이를 통해 클라이언트와 서버 간의 거리를 줄여 데이터 송수신의 지연을 줄일 수 있습니다.</p><p>예를 들어, 세계적으로 유명한 CDN 서비스인 <code class="language-plaintext highlighter-rouge">Cloudflare</code>는 다음과 같이 전 세계에 서버를 두고 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.png" alt="Web cache and S3 - cloudflare server list"/></picture><p><code class="language-plaintext highlighter-rouge">Cloudflare</code>를 이용하면 정적 파일을 <code class="language-plaintext highlighter-rouge">Cloudflare</code>가 제공하는 서버에 복사하여 클라이언트와 가까운 서버에서 콘텐츠를 제공할 수 있습니다.</p><h3 id="브라우저-캐시browser-cache">브라우저 캐시(Browser cache)</h3><p>클라이언트 측에서 보면 가장 가까운 서버는 클라이언트 자체입니다. 브라우저는 클라이언트가 한 번 액세스한 사이트에서 일부 콘텐츠를 클라이언트 스토리지에 저장하고 다시 액세스할 때 이 저장된 콘텐츠를 사용하게 하는 브라우저 캐시 기능을 제공합니다.</p><p>Chrome 브라우저의 경우 다음 위치에 캐시를 합니다.</p><ul><li>Windows: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;User Name&gt;\AppData\Local\Google\Chrome\User Data\Default\Cache</code></li><li>macOS: <code class="language-plaintext highlighter-rouge">/Users/&lt;User Name&gt;/Library/Caches/Google/Chrome/Default/Cache</code></li></ul><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="웹-캐시-동작-방식">웹 캐시 동작 방식</h2><p>웹 캐시가 동작하는 방식에 대해서 알아보도록 하겠습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache process"/></picture><ol><li>사용자가 브라우저에서 서비스에 액세스합니다.</li><li>브라우저는 브라우저에 캐시된 것이 있는지 확인하고 캐시가 있는 경우 이를 사용하여 화면에 표시합니다.</li><li>브라우저에 캐시가 없으면 CDN에 캐시가 있는지 확인합니다. CDN에 캐시가 있는 경우 캐시를 사용합니다.</li><li>CDN에 캐시가 없으면 실제 서버에서 콘텐츠를 가져옵니다.</li><li>이때 CDN은 캐시할 필요가 있는지 확인하고 캐시할 수 있는 경우 캐시합니다.</li><li>브라우저도 마찬가지로 캐시할 수 있는 경우 캐시합니다.</li><li>다음부터 사용자가 같은 콘텐츠에 액세스할 때 브라우저와 CDN에서 캐시된 콘텐츠를 사용합니다.</li></ol><h2 id="웹-캐시-설정">웹 캐시 설정</h2><p>브라우저와 CDN은 어떤 기준으로 캐시를 설정할까요? 브라워저와 CDN은 HTTP 응답 헤더에 <code class="language-plaintext highlighter-rouge">Expires</code>, <code class="language-plaintext highlighter-rouge">Cache-Control</code>, <code class="language-plaintext highlighter-rouge">Etag</code>, <code class="language-plaintext highlighter-rouge">Last-Modified</code> 등을 확인하여 캐시 여부를 결정합니다.</p><p>HTTP 응답 헤더에 캐시는 다음과 같은 방법으로 설정할 수 있습니다.</p><ul><li>Nginx 설정</li></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
    listen 80;
    server_name example.com;

    location / {
        # Set Cache-Control
        add_header Cache-Control "max-age=3600, public";

        # Set Expires
        expires 1h;
    }
}
</code></pre></div></div><ul><li>웹 서버 설정(NodeJS의 Express 예)</li></ul><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Set Cache-Control</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cache-Control</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">max-age=3600, public</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// Set Expires</span>
    <span class="kd">const</span> <span class="nx">maxAgeInSeconds</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="nx">date</span><span class="p">.</span><span class="nx">setSeconds</span><span class="p">(</span><span class="nx">date</span><span class="p">.</span><span class="nx">getSeconds</span><span class="p">()</span> <span class="o">+</span> <span class="nx">seconds</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">expiryDate</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">toUTCString</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Expires</span><span class="dl">'</span><span class="p">,</span> <span class="nx">expiryDate</span><span class="p">);</span>

    <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Server is running on port 3000</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>이렇게 설정된 HTTP 응답 헤더를 확인하여 CDN과 브라우저가 캐시를 설정하게 됩니다.</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="aws-s3와-cloudfront">AWS S3와 CloudFront</h2><p>AWS의 S3와 CloudFront를 사용하여 정적 웹 사이트를 서비스할 수 있습니다.</p><ul><li>S3(Simple Storage Service): 정적 파일을 저장하는 서비스</li><li>CloudFront: CDN 서비스</li></ul><p>S3는 스토리지 서비스이지만 정적 파일로 웹 서비스를 할 수 있는 서버 기능도 제공하고 있습니다.</p><p>일반적으로 HTML, CSS, JavaScript로 개발된 정적 웹 페이지나 React, Vue, Angular 등의 프론트엔드 프레임워크로 개발된 웹 애플리케이션의 빌드 결과물을 S3에 업로드하여 CloudFront를 통해 서비스하게 됩니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.png" alt="Web cache and S3 - AWS S3 and CloudFront cache"/></picture><p>이때, S3에 업로드한 파일 설정으로 통해 브라우저 캐시와 CDN(CloudFront) 캐시를 설정할 수 있습니다.</p><h2 id="aws-s3-캐시-설정">AWS S3 캐시 설정</h2><p>캐시는 HTTP의 응답 헤더에 <code class="language-plaintext highlighter-rouge">Expires</code>나 <code class="language-plaintext highlighter-rouge">Cache-Control</code>을 설정하기 때문에 기본적으로 프론트엔드 측에서 설정할 수 없습니다.</p><p><code class="language-plaintext highlighter-rouge">CloudFront + S3</code>는 서버가 없기 때문에 HTTP 헤더를 설정하는 서버 코드를 추가할 수 없습니다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">S3</code>가 서버 기능을 가지고 있으므로, S3의 설정을 통해 바꾸는 것으로 캐시를 설정하게 됩니다.</p><p>AWS가 제공하는 CLI 툴을 사용하여 S3에 파일을 업로드할 때, 다음과 같은 명령어를 사용합니다. 이때, <code class="language-plaintext highlighter-rouge">--cache-control</code> 옵션을 사용하면 캐시를 설정할 수 있습니다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws s3 <span class="nb">cp</span> &lt;Target directory&gt; s3://&lt;S3 Bucket name&gt; <span class="nt">--recursive</span> <span class="nt">--exclude</span> <span class="s2">"assets/*"</span> <span class="nt">--cache-control</span> <span class="s1">'public,max-age=60,stale-while-revalidate=2592000’
</span></code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">Target directory</code>: S3에 업로드할 빌드 결과가 있는 로컬 폴더 경로</li><li><code class="language-plaintext highlighter-rouge">S3 Bucket name</code>: 파일을 업로드할 대상이 되는 S3의 Bucket name</li><li><code class="language-plaintext highlighter-rouge">--recursive</code> 옵션: <code class="language-plaintext highlighter-rouge">aws s3 cp</code>는 기본 파일 하나를 복사하는 명령이므로, 지정된 디렉토리의 모든 파일을 업로드하기 위해 <code class="language-plaintext highlighter-rouge">--recursive</code> 옵션 사용</li><li><code class="language-plaintext highlighter-rouge">--exclude "assets/*"</code>: 업로드 제외 대상 설정</li><li><code class="language-plaintext highlighter-rouge">--cache-control 'public,max-age=60,stale-while-revalidate=2592000'</code>: 캐시 설정</li><li><code class="language-plaintext highlighter-rouge">max-age=60</code>: 60초 동안 캐시</li><li><code class="language-plaintext highlighter-rouge">stale-while-revalidate</code>: <code class="language-plaintext highlighter-rouge">max-age</code>에 의해 캐시가 종료된 경우, 백그라운드에서 콘텐츠를 다시 확인하고 캐시하는 동안, 만료된 캐시를 최대 30일 동안 제공하도록 설정</li></ul><h2 id="github-actions">GitHub Actions</h2><p>다음은 <code class="language-plaintext highlighter-rouge">GitHub Actions</code>를 사용하여 S3에 파일을 업로드하는 코드입니다.</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure AWS credentials</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">aws-actions/configure-aws-credentials@v4</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">role-to-assume</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">aws-region</span><span class="pi">:</span> <span class="s">ap-northeast-1</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload file to S3</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">aws s3 rm s3://$ --recursive</span>
    <span class="s">aws s3 cp apps/dist s3://$ --recursive --exclude "assets/*" --cache-control 'public,max-age=60,stale-while-revalidate=2592000'</span>
    <span class="s">aws s3 sync apps/dist/assets s3://$/assets --cache-control 'public,max-age=60,immutable'</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">aws s3 rm</code>을 사용하여 모든 파일을 삭제한 후, <code class="language-plaintext highlighter-rouge">aws s3 cp</code>를 사용하여 파일을 업로드합니다. 마지막에 <code class="language-plaintext highlighter-rouge">assets</code> 폴더를 <code class="language-plaintext highlighter-rouge">aws s3 sync</code>를 사용하여 업로드합니다.</p><h2 id="stale-while-revalidate를-사용한-무중단-배포">stale-while-revalidate를 사용한 무중단 배포</h2><p>AWS에서 소개된 사용법입니다.</p><ul><li><a href="https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/" rel="nofollow noreferrer" target="_blank">https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/</a></li></ul><p>stale-while-revalidate를 사용하면 중단없이 서비스 버전을 업데이트할 수 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.png" alt="Web cache and S3 - stale-while-revalidate option for no downtime deployment"/></picture><ol><li>사용자가 브라우저에서 서비스를 실행합니다.</li><li>V1에서 이미 서비스를 이용하고 있는 유저는, 브라우저에 stale-while-revalidate가 설정된 V1의 캐시가 있으므로, 그것을 우선 사용하게 됩니다.</li><li>브라우저는 백그라운드에서 캐시가 종료된(max-age) 콘텐츠를 CloudFront(CDN)에 요청하게 됩니다.</li><li>CloudFront는 V2로 업데이트된 캐시가 있으므로, 그것을 브라우저에 제공합니다.</li><li>브라우저는 CloudFront로부터 전달받은 콘텐츠를 캐시해 다음부터 이것을 사용하게 합니다.</li><li>만약 CloudFront의 캐시도 갱신이 필요한 경우(max-age), 우선은 stale-while-revalidate가 설정된 V1의 캐시를 브라우저에 제공한 후, 백그라운드에서 실제의 서버로부터 콘텐츠를 가져와 자신의 캐시를 갱신합니다.</li></ol><h2 id="완료">완료</h2><p>이것으로 웹 캐시(Web cache)에 대해서 알아보고, AWS S3와 CloudFront를 사용하여 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아보았습니다.</p><p>이 블로그 포스트가 웹 캐시의 이해와 AWS에서 웹 캐시를 적용할때 도움이 되었기를 바랍니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[웹 개발에서의 캐시(Cache)에 대해서 알아보고, AWS S3와 CloudFront를 사용하여 정적 파일로 웹 서비스를 제공할 때 캐시를 적용하는 방법에 대해서 알아봅시다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">소프트웨어 개발 배포 전략</title><link href="https://deku.posstree.com/ko/environment/deployment-strategy/" rel="alternate" type="text/html" title="소프트웨어 개발 배포 전략"/><published>2024-08-07T00:00:00+09:00</published><updated>2024-08-09T14:33:57+09:00</updated><id>https://deku.posstree.com/environment/deployment-strategy-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/deployment-strategy/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%8A%A4-%EB%B0%B0%ED%8F%AC">인플레이스 배포</a></li><li><a href="#%EB%A1%A4%EB%A7%81-%EB%B0%B0%ED%8F%AC">롤링 배포</a></li><li><a href="#%EB%B8%94%EB%A3%A8-%EA%B7%B8%EB%A6%B0-%EB%B0%B0%ED%8F%AC">블루 그린 배포</a></li><li><a href="#%EC%B9%B4%EB%82%98%EB%A6%AC-%EB%B0%B0%ED%8F%AC">카나리 배포</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>소프트웨어 개발에서 배포 전략은 서비스를 안정적으로 운영하기 위한 방법입니다. 배포 전략은 다양한 종류가 있으며, 각각의 특징에 따라 적합한 배포 전략을 선택하여 사용해야 합니다. 이번 블로그 포스트에서는 배포 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.</p><h2 id="인플레이스-배포">인플레이스 배포</h2><p>인플레이스 배포(In-place deployment)는 금융기관이나 게임 업데이트처럼 유저에게 통지를 하고 그 시간에 서비스를 멈추고 업데이트하는 구조입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" alt="Deployment strategy - in place deployment"/></picture><ol><li>운영중인 서버를 중지합니다.</li><li>새 애플리케이션을 배포합니다.</li><li>중지된 서버를 다시 시작합니다.</li></ol><p>인플레이스 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>모든 사용자는 항상 동일한 버전의 응용 프로그램을 사용합니다.</li><li>구버전, 신버전이 동시에 존재하지 않기 때문에, 호환성을 생각할 필요가 없고, 호환성을 지원하지 못해 발생하는 문제가 나올 가능성이 없다.</li><li>배포에 관한 인프라 구성이 필요없고, 배포도 간단하기 때문에 비용적으로 저렴하다.</li></ul><p>단점</p><ul><li>서비스를 일시 중지해야 합니다.</li><li>배포가 완료된 후, 문제가 있어 롤백할 필요가 있는 경우, 서비스를 멈춰야함으로 롤백하기 어렵다.</li><li>배포 도중 문제가 발생하면 서비스 중지 시간이 길어질 수 있습니다.</li></ul><p>금융 기관처럼 배포 할 때 이전 버전과 새로운 버전에서 문제가 발생하면 중요한 문제(금전적 문제)가 되는 서비스, 또는 게임처럼 새로운 버전을 사용하지 않으면 새로운 아이템, 지도, 게임 시스템 사용할 수 없는 서비스는 인플레이스 배포 방법을 사용합니다.</p><h2 id="롤링-배포">롤링 배포</h2><p>롤링 배포(Rolling-update Deployment)는 운용할 수 있는 서버 대수가 제한된 경우, 인플레이스 배포와는 달리 중단 없이 배포할 필요가 있는 경우, 사용하는 방법입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" alt="Deployment strategy - rolling update deployment"/></picture><ol><li>현재 운영 중인 서버 중 하나를 외부(사용자)에서 액세스할 수 없도록 합니다.</li><li>액세스가 없는지 확인합니다.</li><li>액세스를 중지한 서버에 새 응용 프로그램을 배포합니다.</li><li>배포된 서버를 외부에서 액세스할 수 있도록 합니다.</li><li>새로 배포한 서버가 외부에서 액세스할 수 있는지 확인합니다.</li><li>모든 서버가 새 버전의 애플리케이션이 될 때까지 1~5를 반복합니다.</li></ol><p>롤링 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>중단 없이 배포할 수 있습니다.</li><li>여러 서버에 배포하기 때문에, 새롭게 배포한 서버에 문제가 발생하면 배포를 중단하거나 롤백할 수 있습니다.</li><li>여러 서버를 최대 이용 가능한 상황에서 배포하기 때문에 부하가 분산된다.</li></ul><p>단점</p><ul><li>서버 대수가 제한되어 있는 상태에서 서버 1대를 정지해 배포를 하기 때문에, 일시적 다른 서버에 부하가 걸릴 가능성이 있다.</li><li>1대씩 배포를 하기 때문에 전부 배포되기까지 상당히 시간이 걸린다.</li><li>구버전과 신버전이 동시에 운용되고 있으므로, 호환성이 있는 어플리케이션을 개발해 배포할 필요가 있다.</li></ul><p>이 배포 방법은 운용 자금에 제한이 있어 서버를 늘릴 수 없는 서비스나 회사에서 사용하며, 중단 없이 서비스를 운용할 때 자주 사용합니다.</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="블루-그린-배포">블루 그린 배포</h2><p>블루 그린 배포(Blue/Green Deployment)는 서버의 제한이 없으며 서비스를 중단없이 배포하고 싶은 경우, 자주 사용하는 방법입니다. 새 버전의 어플리케이션을 프로덕션 환경에서 테스트하려는 경우에도 이 방법을 사용합니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" alt="Deployment strategy - Blue green deployment"/></picture><ol><li>새 버전을 배포하기 위한 서버(Green)를 만듭니다.</li><li>새로 만든 서버에 새 어플리케이션을 배포합니다.</li><li>새로운 액세스는 새로운 서버에 흐르게 하고, 기존의 서버(Blue)에는 새로운 액세스가 접근하지 못하도록 합니다.</li><li>새 서버에 액세스할 때 또는 새 어플리케이션에서 문제가 발생하면 새로운 액세스를 기존 서버로 흐르게 하여 롤백합니다.</li><li>새로운 서버의 액세스가 특별히 문제가 없으면 기존의 서버를 지웁니다.</li></ol><p>블루 그린 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>서비스를 중단 없이 배포할 수 있습니다.</li><li>새 버전을 배포할 때, 이전 버전의 서버가 아직 살아 있기 때문에 문제가 있었을 때 롤백이 빠릅니다.</li><li>새 버전과 이전 버전의 전환이 간단하기 때문에 프로덕션 환경에서 신버전을 테스트할 수 있다.</li></ul><p>단점</p><ul><li>새 버전과 이전 버전의 서버를 준비해야하므로 일시적인 비용이 두 배가 됩니다.</li><li>새 버전이 문제가 없는지 확인하고 이전 버전을 지우므로 배포를 완료하는 데 시간이 걸립니다.</li><li>배포를 완료하고 이전 버전의 서버를 삭제했다면, 롤백을 할 수 없습니다. 이 경우, 롤백하려면 이전 버전을 새로 배포해야 합니다.</li></ul><p>새 버전과 이전 버전이 동시에 존재해도 문제가 없는 서비스로, 배포되는 도중에 기존 액세스를 강제적으로 끊지 않으므로, Session이나 Socket등을 사용하여 사용자의 액세스를 관리하는 서비스에서 사용합니다.</p><h2 id="카나리-배포">카나리 배포</h2><p>카나리 배포(Canary deployment)는 A/B 테스트, 새로운 버전의 기능의 피드백이 필요한 경우, 서비스의 버전 업데이트를 신중하게 하고 싶은 경우, 개발중의 기능을 프로덕션 환경에서 테스트해 보고 싶은 경우에 사용할 수 있는 배포 방법입니다.</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/canary.webp" alt="Deployment strategy - Canary deployment"/></picture><ol><li>새 버전을 배포한 서버를 준비합니다.</li><li>서비스 액세스중 일부를 새 버전으로 돌립니다.</li><li>새로운 버전이 좋다고 판단되면 사용자의 액세스를 점진적으로 늘립니다.</li><li>좋지 않다고 판단되면 이전 버전의 서버에 사용자 액세스를 반환합니다.</li><li>모든 액세스가 새 버전의 서버로 돌아가면 이전 버전의 서버를 지웁니다.</li></ol><p>카나리 배포는 다음과 같은 장단점이 있습니다.</p><p>장점</p><ul><li>A/B 테스트나 새로운 기능의 반응을 관찰하여 새로운 기능을 도입할지 여부를 결정할 수 있다.</li><li>롤백이 쉽습니다.</li><li>모니터링하면서 배포가 가능하므로 더 안전하게 배포가 가능하다.</li></ul><p>단점</p><ul><li>새 버전과 이전 버전의 서버를 준비해야하므로 일시적인 비용이 두 배가 됩니다.</li><li>새 버전이 문제가 없는지 확인하고 이전 버전을 지우므로 배포를 완료하는 데 시간이 걸립니다.</li><li>서비스를 사용하는 사람에 따라 보는 화면이 다르거나 새로운 기능을 사용할 수 없게 되기 때문에 UX 불일치 문제가 발생할 수 있습니다.</li></ul><p>새로운 기능에 대해 A/B 테스트를 하고 싶은 경우, 사용자의 액세스가 많은 경우, 이 배포 방법을 사용합니다. 또는 개발 중인 기능을 프로덕션의 일부 트래픽을 받게 하여 문제가 없는지 확인할 때도 사용합니다.</p><h2 id="완료">완료</h2><p>이것으로 소프트웨어 개발에서 서비스 배포 전략의 종류와 사용법에 대해서 알아보았습니다. 이 블로그 포스트가 현재 운영중인 서비스와 리소스에 따라 적합한 배포 전략을 선택하는데 도움이 되었으면 좋겠습니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[소프트웨어 개발에서 서비스 배포 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ko"><title type="html">소프트웨어 개발을 위한 브랜치 전략</title><link href="https://deku.posstree.com/ko/environment/branch-strategy/" rel="alternate" type="text/html" title="소프트웨어 개발을 위한 브랜치 전략"/><published>2024-08-04T00:00:00+09:00</published><updated>2024-08-08T20:53:30+09:00</updated><id>https://deku.posstree.com/environment/branch-strategy-ko</id><content type="html" xml:base="https://deku.posstree.com/environment/branch-strategy/"><![CDATA[<div id="contents_list"><h2 id="section">목차</h2><ul><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li><li><a href="#git-flow-%EC%A0%84%EB%9E%B5">git-flow 전략</a></li><li><a href="#github-flow-%EC%A0%84%EB%9E%B5">GitHub flow 전략</a></li><li><a href="#gitlab-flow-%EC%A0%84%EB%9E%B5">GitLab flow 전략</a></li><li><a href="#trunk-based-development-%EC%A0%84%EB%9E%B5">Trunk-Based Development 전략</a></li><li><a href="#scaled-trunk-based-development-%EC%A0%84%EB%9E%B5">Scaled Trunk-Based Development 전략</a></li><li><a href="#%EC%99%84%EB%A3%8C">완료</a></li></ul></div><h2 id="개요">개요</h2><p>브랜치 전략은 여러 개발자가 협업할 때 코드를 효율적으로 관리하기 위한 방법입니다. 브랜치 전략은 다양한 종류가 있으며, 각각의 특징에 따라 적합한 브랜치 전략을 선택하여 사용해야 합니다. 이번 블로그 포스트에서는 브랜치 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.</p><h2 id="git-flow-전략">git-flow 전략</h2><p><code class="language-plaintext highlighter-rouge">git-flow</code> 브랜치 전략은 Vincent Driessen에 의해 제안된 브랜치 전략입니다. 브랜치 전략 중에서 가장 유명한 브랜치 전략으로써 많은 회사가 사용하고 있습니다.</p><ul><li><a href="https://nvie.com/posts/a-successful-git-branching-model/" rel="nofollow noreferrer" target="_blank">https://nvie.com/posts/a-successful-git-branching-model/</a></li></ul><p><code class="language-plaintext highlighter-rouge">git-flow</code> 브랜치 전략은 <code class="language-plaintext highlighter-rouge">master</code>, <code class="language-plaintext highlighter-rouge">develop</code>, <code class="language-plaintext highlighter-rouge">feature</code>, <code class="language-plaintext highlighter-rouge">release</code>, <code class="language-plaintext highlighter-rouge">hotfix</code> 브랜치로 구성되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/branch_strategy/git-flow.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/branch_strategy/git-flow.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/branch_strategy/git-flow.png" alt="Branch strategy - git-flow"/></picture><ul><li>master 브랜치 <ul><li>master 브랜치는 항상 제품으로 출시할 수 있는 안정적인 코드를 유지하는 데 사용됩니다.</li><li>배포 가능한 버전은 이 브랜치에서 Tag로 관리됩니다.</li></ul></li><li>develop 브랜치 <ul><li>develop 브랜치는 다음 릴리스를 위해 개발하는 코드를 포함합니다.</li><li>새로운 기능과 버그 수정을 할 브랜치는 여기에서 만듭니다.</li></ul></li><li>feature 브랜치 <ul><li>새로운 기능을 개발하기 위한 브랜치로, develop에서 만듭니다.</li><li>각 기능은 별도의 브랜치로 개발을 하고, 개발이 완료되면 develop 브랜치에 병합합니다.</li></ul></li><li>release 브랜치 <ul><li>릴리스를 준비하는 단계에서 사용하는 브랜치로, develop 브랜치로부터 만듭니다.</li><li>배포 준비 작업(버전 번호 업데이트, 문서 등)을 수행하고 테스트를 진행한 후 master 및 develop 브랜치에 병합합니다.</li></ul></li><li>hotfix 브랜치 <ul><li>긴급한 버그 수정을 하기 위한 브랜치입니다. master 브랜치로 만듭니다.</li><li>수정이 완료되면 master와 develop 브랜치에 병합합니다.</li></ul></li></ul><p>git-flow에서는 release 브랜치가 master에 병합될 때, hotfix 브랜치가 master에 병합될 때 릴리스됩니다. 그런 다음 Git tag를 사용하여 출시된 시점을 관리합니다.</p><h2 id="github-flow-전략">GitHub flow 전략</h2><p><code class="language-plaintext highlighter-rouge">GitHub flow</code>는 쉽고 직관적인 Git 브랜치 전략 중 하나로 GitHub이 제안하였습니다. 이 전략은 주로 웹 개발에서 릴리스 관리를 위한 간단한 워크플로우를 제공합니다.</p><ul><li><a href="https://docs.github.com/get-started/using-github/github-flow" rel="nofollow noreferrer" target="_blank">https://docs.github.com/get-started/using-github/github-flow</a></li></ul><p><code class="language-plaintext highlighter-rouge">GitHub flow</code> 브랜치 전략은 <code class="language-plaintext highlighter-rouge">master</code>, <code class="language-plaintext highlighter-rouge">feature</code> 브랜치로 구성되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/branch_strategy/github-flow.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/branch_strategy/github-flow.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/branch_strategy/github-flow.png" alt="Branch strategy - GitHub flow"/></picture><ul><li>master 브랜치 <ul><li>master 브랜치는 항상 제품으로 출시할 수 있는 안정적인 코드를 유지하는 데 사용됩니다.</li></ul></li><li>feature 브랜치 <ul><li>새로운 기능을 개발하기 위한 브랜치로, master에서 만듭니다.</li><li>이 브랜치로 코드를 수정하고 커밋합니다.</li></ul></li><li>Pull Request (PR) <ul><li>기능과 작업이 끝나면 개발자는 master 브랜치에 병합하기 위해 Pull Request를 만듭니다.</li><li>코드 리뷰나 테스트를 통과하지 않으면 병합할 수 없습니다.</li></ul></li><li>코드 리뷰와 테스트 <ul><li>다른 개발자는 Pull Request를 검토합니다.</li><li>자동화된 테스트를 통과하면 코드가 안전한 것으로 간주됩니다.</li></ul></li><li>Merge <ul><li>Pull Request가 모든 조건에 도달하면 master에 병합됩니다.</li></ul></li></ul><p>GitHub flow에서는 feature 브랜치가 master에 병합되면 릴리스됩니다. GitHub flow에서는 자주 출시하는 것이 중요하며 사용자에게 빨리 새로운 기능과 버그 수정을 제공할 수 있습니다.</p><h2 id="gitlab-flow-전략">GitLab flow 전략</h2><p><code class="language-plaintext highlighter-rouge">GitLab flow</code>는 GitLab이 제안한 브랜치 전략입니다. GitLab flow는 기본 GitHub flow와 동일합니다. 그러나 출시할 타이밍이 있는 경우(iOS 앱 배포에는 앱 심사가 있으며, 정기적으로 배포를 하는 서비스 등이 이에 해당합니다), 사용할 수 있는 전략입니다.</p><ul><li><a href="https://docs.gitlab.co.jp/ee/topics/gitlab_flow.html" rel="nofollow noreferrer" target="_blank">https://docs.gitlab.co.jp/ee/topics/gitlab_flow.html</a></li></ul><p><code class="language-plaintext highlighter-rouge">GitLab flow</code> 브랜치 전략은 <code class="language-plaintext highlighter-rouge">master</code>, <code class="language-plaintext highlighter-rouge">feature</code> 브랜치와 배포를 위한 브랜치(production, staging등)로 구성되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/branch_strategy/gitlab-flow.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/branch_strategy/gitlab-flow.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/branch_strategy/gitlab-flow.png" alt="Branch strategy - GitLab flow"/></picture><ul><li>master 브랜치 <ul><li>master 브랜치는 항상 제품으로 출시할 수 있는 안정적인 코드를 유지하는 데 사용됩니다.</li></ul></li><li>feature 브랜치 <ul><li>개발자가 새로운 기능과 작업을 할 수있는 브랜치로 master 브랜치에서 만듭니다.</li><li>이 브랜치로 코드를 수정하고 커밋합니다.</li></ul></li><li>Merge Request <ul><li>기능과 작업이 끝나면 개발자는 master 브랜치에 병합하기 위해 Merge Request를 만듭니다.</li><li>코드 검토 및 테스트를 통과하면 병합이 가능합니다.</li></ul></li><li>코드 리뷰와 테스트 <ul><li>다른 개발자가 Merge Request를 검토합니다.</li><li>자동화된 테스트가 통과되면 안전하다고 생각할 수 있습니다.</li></ul></li><li>production(stable, staging) 브랜치 <ul><li>production(stable, staging) 환경에 배포 가능한 안정적인 코드를 가지는 브랜치입니다.</li><li>배포하기 위해 만드는 브랜치로 마스터 브랜치에서 만듭니다.</li></ul></li><li>hotfix 브랜치 <ul><li>GitLab flow에는 hotfix 브랜치가 없습니다. 문제가 있으면 master 브랜치에서 브랜치를 만들어 master 브랜치에 병합합니다. 그런 다음 릴리스 브랜치에 Git의 cherry pick 기능을 사용하여 production 브랜치에 병합합니다.</li></ul></li></ul><p>GitLab flow는 릴리스 타이밍이 있는 경우 사용할 수 있는 브랜치 전략입니다. 개발한 내용(feature 브랜치)은 master 브랜치에 병합하여 배포가 필요한 타이밍에 master 브랜치에서 production(stable, staging) 브랜치를 만들어 배포합니다.</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="trunk-based-development-전략">Trunk-Based Development 전략</h2><p><code class="language-plaintext highlighter-rouge">Trunk-Based Development(TBD)</code> 전략은 신속한 소프트웨어 릴리스와 높은 협업을 목표로 하는 간단하고 효과적인 Git 브랜치 전략입니다. TBD 전략은 지속적인 통합(CI)과 지속적인 배포(CD)를 강조합니다.</p><ul><li><a href="https://trunkbaseddevelopment.com/" rel="nofollow noreferrer" target="_blank">https://trunkbaseddevelopment.com/</a></li></ul><p><code class="language-plaintext highlighter-rouge">TBD</code> 브랜치 전략은 하나의 브랜치(trunk, master, main)로 구성되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.png" alt="Branch strategy - Trunk-Based Development"/></picture><ul><li>하나의 브랜치(trunk, master, main) <ul><li>TBD에서는 주로 master(main) 브랜치만 사용합니다. master 브랜치는 항상 제품으로 출시할 수 있는 안정적인 코드를 유지하는 데 사용됩니다.</li></ul></li><li>빈번한 커밋 <ul><li>개발자는 작은 단위로 자주 커밋을 합니다. 이 코드의 변경 사항을 빠르게 공유하여 지점 간 충돌이 발생하지 않도록 합니다.</li></ul></li><li>Pull Request 대신 직접 커밋 및 코드 검토 <ul><li>작은 변경 사항에 대해 Pull Request를 만드는 대신 master 브랜치에 직접 커밋하여 코드 검토를 진행합니다. 이것은 분기 간 충돌을 최소화할 수 있습니다.</li></ul></li><li>릴리스 <ul><li>master에 직접 커밋을 하기 때문에, 릴리스는 타이밍을 정해 실시합니다.</li></ul></li></ul><p>TBD는 24시간 이내에 모든 멤버가 커밋을 하도록 합니다. 다시 말해, 24시간 이내에 커밋할 수 있을 정도로 작은 코드를 자주 작성하는 것이 중요합니다.</p><p>TBD는 구글이 사용하는 것으로 유명합니다.</p><ul><li><a href="https://www.youtube.com/watch?v=W71BTkUbdqE&amp;t=869s" rel="nofollow noreferrer" target="_blank">https://www.youtube.com/watch?v=W71BTkUbdqE&amp;t=869s</a></li><li><a href="https://trunkbaseddevelopment.com/game-changers/#google-revealing-their-monorepo-trunk-2016" rel="nofollow noreferrer" target="_blank">https://trunkbaseddevelopment.com/game-changers/#google-revealing-their-monorepo-trunk-2016</a></li></ul><h2 id="scaled-trunk-based-development-전략">Scaled Trunk-Based Development 전략</h2><p><code class="language-plaintext highlighter-rouge">Scaled Trunk-Based Development(STBD)</code> 전략은 Trunk-Based Development 전략과 동일하지만 master 브랜치에 직접 커밋을 하지 않고 feature 브랜치를 만들고 커밋한 후, feature 브랜치를 master에 병합합니다.</p><ul><li><a href="https://trunkbaseddevelopment.com/" rel="nofollow noreferrer" target="_blank">https://trunkbaseddevelopment.com/</a></li></ul><p><code class="language-plaintext highlighter-rouge">STBD</code> 브랜치 전략은 <code class="language-plaintext highlighter-rouge">TBD</code>와 동일하게 하나의 브랜치(trunk, master, main)와 feature 브랜치로 구성되어 있습니다.</p><picture><source srcset="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/branch_strategy/trunk-based-development.png" alt="Branch strategy - Trunk-Based Development"/></picture><ul><li>하나의 브랜치(trunk, master, main) <ul><li>STBD에서는 주로 master(main) 브랜치만 사용합니다. master 브랜치는 항상 제품으로 출시할 수 있는 안정적인 코드를 유지하는 데 사용됩니다.</li></ul></li><li>feature 브랜치 <ul><li>작은 커밋을 하기 위한 브랜치로 짧은 라이프 사이클을 가지는 브랜치입니다.</li></ul></li><li>릴리스 <ul><li>master 브랜치만 관리하므로, 릴리스는 타이밍을 정해 실시합니다.</li></ul></li></ul><p>TBD는 master 브랜치에 직접 커밋을 하고, 코드 리뷰를 함으로 자체적인 개발 체계가 필요합니다. STBD는 TBD의 장점을 사용하면서, 이런 자체적인 체계를 구성하기 힘든 경우에 사용할 수 있는 브랜치 전략입니다.</p><h2 id="완료">완료</h2><p>이것으로 소프트웨어 개발을 위한 브랜치 전략과 그에 대한 사용법에 대해 간단히 알아보았습니다. 자세한 내용은 각 브랜치 전략에 대한 링크를 통해 확인할 수 있습니다.</p><p>브랜치 전략은 개발자들이 협업할 때 코드를 효율적으로 관리하기 위한 방법입니다. 브랜치 전략은 다양한 종류가 있으며, 어떤 브랜치 전략이 더 좋고 나쁘다고 말할 수 없습니다. 각각의 프로젝트와 팀에 맞는 브랜치 전략을 선택하여 사용하거나 이 브랜치 전략을 기반으로 자신만의 브랜치 전략을 만들어 사용하면 좋지 않을까 생각합니다.</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[소프트웨어를 개발하기 위한 브랜치 전략의 종류와 사용법에 대해서 알아보도록 하겠습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/monorepo/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/monorepo/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry></feed>