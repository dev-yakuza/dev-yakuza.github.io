<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://deku.posstree.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://deku.posstree.com/" rel="alternate" type="text/html"/><updated>2024-09-17T12:07:59+09:00</updated><id>https://deku.posstree.com/feed.xml</id><title type="html">Deku</title><subtitle>『Programming Artist, DeKu』</subtitle><author><name>dev.yakuza@gmail.com</name></author><entry xml:lang="ja"><title type="html">[GitHub Actions] GitHub Actions を手動で実行する</title><link href="https://deku.posstree.com/github_actions/execute-github-actions-manually/" rel="alternate" type="text/html" title="[GitHub Actions] GitHub Actions を手動で実行する"/><published>2024-09-13T00:00:00+09:00</published><updated>2024-09-16T16:56:41+09:00</updated><id>https://deku.posstree.com/github_actions/execute-github-actions-manually-ja</id><content type="html" xml:base="https://deku.posstree.com/github_actions/execute-github-actions-manually/"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#workflow_dispatch">workflow_dispatch</a></li><li><a href="#inputs-%E3%82%BF%E3%82%A4%E3%83%97">inputs タイプ</a></li><li><a href="#%E4%BE%8B%E9%A1%8C">例題</a><ul><li><a href="#boolean">boolean</a></li><li><a href="#choice">choice</a></li><li><a href="#number">number</a></li><li><a href="#string">string</a></li><li><a href="#environment">environment</a></li></ul></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>GitHub Actions を使ってると、手動で GitHub Actions を実行する必要がある場合があります。このブログポストでは、GitHub Actions を手動で実行する方法について説明します。</p><h2 id="workflow_dispatch">workflow_dispatch</h2><p><code class="language-plaintext highlighter-rouge">GitHub Actions</code>を手動で実行するには、<code class="language-plaintext highlighter-rouge">workflow_dispatch</code>を使う必要があります。</p><ul><li>公式ドキュメント: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch</a></li></ul><p>この場合、<code class="language-plaintext highlighter-rouge">workflow_dispatch</code>の <code class="language-plaintext highlighter-rouge">inputs</code>を使ってパラメータを渡すことができます。</p><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>は次のように設定できます。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
</code></pre></div></div><h2 id="inputs-タイプ">inputs タイプ</h2><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>の <code class="language-plaintext highlighter-rouge">inputs</code>には次のような種類があります。</p><ul><li><code class="language-plaintext highlighter-rouge">boolean</code>: true または false</li><li><code class="language-plaintext highlighter-rouge">choice</code>: 事前に指定されたオプションの中から選択できる SelectBox</li><li><code class="language-plaintext highlighter-rouge">number</code>: 数字</li><li><code class="language-plaintext highlighter-rouge">string</code>: 文字列</li><li><code class="language-plaintext highlighter-rouge">environment</code>: GitHub に設定された環境変数を使用</li></ul><p>公式ドキュメントでも使える <code class="language-plaintext highlighter-rouge">inputs</code> タイプを確認することができます。</p><ul><li>公式ドキュメント: <a href="https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype" rel="nofollow noreferrer" target="_blank">https://docs.github.com/ko/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputsinput_idtype</a></li></ul><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>の <code class="language-plaintext highlighter-rouge">inputs</code>は次のように設定できます。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">inputs</code>は <code class="language-plaintext highlighter-rouge">type</code> 以外にも <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">required</code>, <code class="language-plaintext highlighter-rouge">default</code> を設定することができます。<code class="language-plaintext highlighter-rouge">type</code> 以外はすべて任意です。</p><h2 id="例題">例題</h2><p>それでは <code class="language-plaintext highlighter-rouge">workflow_dispatch</code>を使って GitHub Actions を手動で実行する例を見ていきましょう。</p><h3 id="boolean">boolean</h3><p>手動で実行する GitHub Actions を作成するために <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_boolean</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">boolean</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>このように作成したファイルを commit して push した後、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Actions</code> タブに移動すると、次のような画面を確認できます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input.png" alt="Execute GitHub Actions manually - Boolean input"/></picture><p>右側に表示された <code class="language-plaintext highlighter-rouge">Run workflow</code> をクリックすると、設定した <code class="language-plaintext highlighter-rouge">boolean</code> タイプの <code class="language-plaintext highlighter-rouge">inputs</code> を確認できます。これを実行すると次のような結果を得ることができます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/boolean_input_result.png" alt="Execute GitHub Actions manually - Boolean input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="choice">choice</h3><p>手動で実行する GitHub Actions を作成するために <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_choice</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">choice</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">warning'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">choice</span>
        <span class="na">options</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s">info</span>
          <span class="pi">-</span> <span class="s">warning</span>
          <span class="pi">-</span> <span class="s">debug</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>このように作成したファイルを commit して push した後、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Actions</code> タブに移動すると、次のような画面を確認できます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input.png" alt="Execute GitHub Actions manually - Choice input"/></picture><p>右側に表示された <code class="language-plaintext highlighter-rouge">Run workflow</code> をクリックすると、設定した <code class="language-plaintext highlighter-rouge">choice</code> タイプの <code class="language-plaintext highlighter-rouge">inputs</code> を確認できます。これを実行すると次のような結果を得ることができます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/choice_input_result.png" alt="Execute GitHub Actions manually - Choice input result"/></picture><h3 id="number">number</h3><p>手動で実行する GitHub Actions を作成するために <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_number</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">number</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="m">20</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">number</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>このように作成したファイルを commit して push した後、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Actions</code> タブに移動すると、次のような画面を確認できます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input.png" alt="Execute GitHub Actions manually - Number input"/></picture><p>右側に表示された <code class="language-plaintext highlighter-rouge">Run workflow</code> をクリックすると、設定した <code class="language-plaintext highlighter-rouge">number</code> タイプの <code class="language-plaintext highlighter-rouge">inputs</code> を確認できます。これを実行すると次のような結果を得ることができます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/number_input_result.png" alt="Execute GitHub Actions manually - Number input result"/></picture><h3 id="string">string</h3><p>手動で実行する GitHub Actions を作成するために <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_string</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">string</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Hello,</span><span class="nv"> </span><span class="s">World!'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">string</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>このように作成したファイルを commit して push した後、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Actions</code> タブに移動すると、次のような画面を確認できます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input.png" alt="Execute GitHub Actions manually - String input"/></picture><p>右側に表示された <code class="language-plaintext highlighter-rouge">Run workflow</code> をクリックすると、設定した <code class="language-plaintext highlighter-rouge">string</code> タイプの <code class="language-plaintext highlighter-rouge">inputs</code> を確認できます。これを実行すると次のような結果を得ることができます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/string_input_result.png" alt="Execute GitHub Actions manually - String input result"/></picture><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h3 id="environment">environment</h3><p><code class="language-plaintext highlighter-rouge">workflow_dispatch</code>の <code class="language-plaintext highlighter-rouge">environment</code> タイプを使用するには、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Settings</code> で <code class="language-plaintext highlighter-rouge">Environment</code> を設定する必要があります。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environments.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environments.png" alt="Execute GitHub Actions manually - Environments"/></picture><p><code class="language-plaintext highlighter-rouge">New environment</code> をクリックして、次のように <code class="language-plaintext highlighter-rouge">Name</code> に <code class="language-plaintext highlighter-rouge">dev</code> を入力してから、<code class="language-plaintext highlighter-rouge">Configure environment</code> をクリックします。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment.png" alt="Execute GitHub Actions manually - New Dev Environment"/></picture><p>その後、<code class="language-plaintext highlighter-rouge">Environment variables</code> の <code class="language-plaintext highlighter-rouge">Add environment variable</code> ボタンをクリックして、次のように <code class="language-plaintext highlighter-rouge">Variable</code> を追加します。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/dev_environment_variable.png" alt="Execute GitHub Actions manually - Dev environment variable"/></picture><p>同じように <code class="language-plaintext highlighter-rouge">prod</code> という環境にも同じ変数を追加します。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/prod_environment_variable.png" alt="Execute GitHub Actions manually - Prod environment variable"/></picture><p>次は、手動で実行する GitHub Actions を作成するために <code class="language-plaintext highlighter-rouge">.github/workflows/manual_test.yml</code> ファイルを作成し、次のように修正し</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GITHUB ACTIONS NAME</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">input_environment</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">This</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">environment</span><span class="nv"> </span><span class="s">input'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">environment</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">deploy-to-staging</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">environment</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Print the input</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo $</span>
</code></pre></div></div><p>このように作成したファイルを commit して push した後、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Actions</code> タブに移動すると、次のような画面を確認できます。</p><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input.png" alt="Execute GitHub Actions manually - Environment input"/></picture><p>右側に表示された <code class="language-plaintext highlighter-rouge">Run workflow</code> をクリックすると、<code class="language-plaintext highlighter-rouge">GitHub</code> の <code class="language-plaintext highlighter-rouge">Settings</code> で <code class="language-plaintext highlighter-rouge">Environment</code> に設定した値が表示されることを確認できます。これを実行すると次のような結果を得ることができます。</p><ul><li>dev 環境</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_dev.png" alt="Execute GitHub Actions manually - Environment input result dev"/></picture><ul><li>prod 環境</li></ul><picture><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.avif" type="image/avif"/><source srcset="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.webp" type="image/webp"/><img src="/assets/images/category/github_actions/execute-github-actions-manually/environment_input_result_prod.png" alt="Execute GitHub Actions manually - Environment input result prod"/></picture><h2 id="完了">完了</h2><p>これで GitHub Actions を手動で実行する方法について説明しました。また、設定可能な <code class="language-plaintext highlighter-rouge">inputs</code> タイプについても説明しました。</p><p>皆さんも <code class="language-plaintext highlighter-rouge">workflow_dispatch</code> とさまざまなタイプの <code class="language-plaintext highlighter-rouge">inputs</code> を使って GitHub Actions を手動で実行してみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actions を手動で実行する方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">[GitHub Actions] モノレポ環境でGitHub Actionsを使ってPRタイトルをチェックする方法</title><link href="https://deku.posstree.com/github_actions/action-check-pr-title/" rel="alternate" type="text/html" title="[GitHub Actions] モノレポ環境でGitHub Actionsを使ってPRタイトルをチェックする方法"/><published>2024-09-10T00:00:00+09:00</published><updated>2024-09-12T09:04:12+09:00</updated><id>https://deku.posstree.com/github_actions/action-check-pr-title-ja</id><content type="html" xml:base="https://deku.posstree.com/github_actions/action-check-pr-title/"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#action-check-pr-title">action-check-pr-title</a></li><li><a href="#github-actions-%E7%94%9F%E6%88%90">GitHub Actions 生成</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>私は <code class="language-plaintext highlighter-rouge">Release Drafter</code> を使って GitHub のリリースノートを自動化しています。</p><ul><li><a href="https://deku.posstree.com/share/github-actions/release-drafter/" target="\_blank">[GitHub Actions] Release notes の自動化</a></li></ul><p>この <code class="language-plaintext highlighter-rouge">Release Drafter</code>はGitHubのPRのLabelを基準に動作します。<code class="language-plaintext highlighter-rouge">Release Drafter</code>はLabelを自動で生成する機能を提供しており、この時PRのタイトルを使います。そのため、PRのタイトルは重要です。</p><p>以前はPRのタイトルをチェックするため、<a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>を使いました。</p><ul><li><a href="https://deku.posstree.com/share/github-actions/pr-title-checker/" target="\_blank">[GitHub Actions] Pull request のタイトルチェック</a></li></ul><p>しかし、現在のモノレポプロジェクトでは、この <code class="language-plaintext highlighter-rouge">Conventional PR Title Action</code>だけでは十分ではなく、他のGitHub Actionsを使うことになりました。</p><ul><li><a href="https://deku.posstree.com/environment/repository_strategy/" target="\_blank">[プロジェクト管理] リポジトリ戦略</a></li></ul><p>今回のブログポストでは、<code class="language-plaintext highlighter-rouge">action-check-pr-title</code>を使ってPRを作成した際、PRのタイトルをチェックする方法について説明します。</p><h2 id="action-check-pr-title">action-check-pr-title</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>は正規表現を使ってPRのタイトルをチェックするGitHub Actionsです。</p><ul><li><a href="https://github.com/Slashgear/action-check-pr-title" rel="nofollow noreferrer" target="\_blank">action-check-pr-title</a></li></ul><h2 id="github-actions-生成">GitHub Actions 生成</h2><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>を使ってPRのタイトルをチェックするGitHub Actionsを生成するために、<code class="language-plaintext highlighter-rouge">.github/workflows/check_pr_title.yml</code>ファイルを生成し、以下のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
      <span class="pi">-</span> <span class="s">reopened</span>
      <span class="pi">-</span> <span class="s">edited</span>
      <span class="pi">-</span> <span class="s">synchronize</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-pr-title</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Pull Request</code>のタイトルをチェックする部分をもう少し詳しく見てみます。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check PR Title</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">Slashgear/action-check-pr-title@v4.3.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">regexp</span><span class="pi">:</span> <span class="s1">'</span><span class="s">(feat|fix|chore|docs|style|refactor|test|build|ci)\((SERVICE1|SERVICE2|template|components|config|common)\):</span><span class="nv"> </span><span class="s">.+'</span>
          <span class="na">helpMessage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Example:</span><span class="nv"> </span><span class="s">'feat(SERVICE1):</span><span class="nv"> </span><span class="s">example</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">title'"</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">action-check-pr-title</code>が提供する<code class="language-plaintext highlighter-rouge">regexp</code>オプションを使って<code class="language-plaintext highlighter-rouge">PR</code>のタイトルをチェックします。ここで使う正規表現は以下のようなPRタイトルを許可します。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feat<span class="o">(</span>SERVICE1<span class="o">)</span>: Add new feature
fix<span class="o">(</span>SERVICE2<span class="o">)</span>: Fix bug
refactor<span class="o">(</span>common<span class="o">)</span>: Refactor code
...
</code></pre></div></div><p>モノレポを使っているため、<code class="language-plaintext highlighter-rouge">Conventional Commits</code>の<code class="language-plaintext highlighter-rouge">Scope</code>領域にサービス名を設定し、これをチェックするように設定しました。</p><ul><li><a href="https://www.conventionalcommits.org/en/v1.0.0/" rel="nofollow noreferrer" target="\_blank">Conventional Commits</a></li></ul><h2 id="完了">完了</h2><p>これで<code class="language-plaintext highlighter-rouge">action-check-pr-title</code>を使ってPRを作成した際、PRのタイトルをチェックする方法について説明しました。<a href="https://github.com/aslafy-z/conventional-pr-title-action/tree/v3/" rel="nofollow noreferrer" target="\_blank">Conventional PR Title Action</a>でも正規表現チェックが可能ですが、設定が簡単ではないため、<code class="language-plaintext highlighter-rouge">action-check-pr-title</code>を使うことにしました。</p><p>皆さんも簡単に正規表現でPRタイトルをチェックしたい場合は、<code class="language-plaintext highlighter-rouge">action-check-pr-title</code>を使ってみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[モノレポ環境でGitHub Actionsを使ってPR(Pull Request)を作成した際、PRのタイトルをチェックする方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">[GitHub Actions] GitHub Actionsでブランチ名をチェックする方法</title><link href="https://deku.posstree.com/github_actions/check-branch-name" rel="alternate" type="text/html" title="[GitHub Actions] GitHub Actionsでブランチ名をチェックする方法"/><published>2024-09-02T00:00:00+09:00</published><updated>2024-09-09T09:52:51+09:00</updated><id>https://deku.posstree.com/github_actions/check-branch-name-ja</id><content type="html" xml:base="https://deku.posstree.com/github_actions/check-branch-name"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#%E3%83%96%E3%83%A9%E3%83%B3%E3%83%81%E5%90%8D%E3%81%AE%E5%A4%89%E6%9B%B4">ブランチ名の変更</a></li><li><a href="#git-hooks">Git hooks</a><ul><li><a href="#%E3%83%96%E3%83%A9%E3%83%B3%E3%83%81%E5%90%8D%E3%81%AE%E7%A2%BA%E8%AA%8Dscript%E3%81%AE%E4%BD%9C%E6%88%90">ブランチ名の確認scriptの作成</a></li><li><a href="#husky%E3%81%AE%E8%A8%AD%E5%AE%9A">Huskyの設定</a></li><li><a href="#lefthook%E3%81%AE%E8%A8%AD%E5%AE%9A">Lefthookの設定</a></li></ul></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>Gitを使ってプロジェクトを開発する際、次のリンクのようにブランチ戦略を使うことがあります。</p><ul><li><a href="https://deku.posstree.com/environment/branch-strategy/" target="\_blank">ソフトウェア開発のためのブランチ戦略</a></li></ul><p>この時、ブランチ戦略に合わせてブランチを作っているか管理が必要な時があります。</p><p>今回のブログポストでは、GitHub Actionsを使ってPRを作った時、ブランチ名をチェックする方法について説明します。</p><h2 id="github-actions">GitHub Actions</h2><p>ブランチ名をチェックするGitHub Actionsを作成するために、<code class="language-plaintext highlighter-rouge">.github/workflows/check-branch-name.yml</code>ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">check-branch-name</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout Repository</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
</code></pre></div></div><p>このGitHub Actionsをもっと見てみましょう。</p><p>私はモノレポでプロジェクトを管理しています。</p><ul><li><a href="https://deku.posstree.com/environment/repository_strategy/" target="\_blank">[プロジェクト管理] リポジトリ戦略</a></li></ul><p>そのため、次のようなブランチ名を使っています。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature/:SERVICE_NAME/:BRANCH_NAME
release/:SERVICE_NAME/:BRANCH_NAME
fix/:SERVICE_NAME/:BRANCH_NAME
...
</code></pre></div></div><p>この時、ブランチ名が<code class="language-plaintext highlighter-rouge">dependabot</code>、<code class="language-plaintext highlighter-rouge">hotfix</code><code class="language-plaintext highlighter-rouge">release</code>、<code class="language-plaintext highlighter-rouge">review</code>、<code class="language-plaintext highlighter-rouge">feature</code>、<code class="language-plaintext highlighter-rouge">fix</code>、<code class="language-plaintext highlighter-rouge">sub-feature</code>などで始まっているか確認し、<code class="language-plaintext highlighter-rouge">SERVICE_NAME</code>を抽出して事前に定義した名前を使っているか確認しています。</p><p>なので、次のようにサービス名とブランチ名を事前に抽出して環境変数に保存しています。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract branch and service name</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">extract_branch_and_service_name</span>
        <span class="na">run </span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">FULL_BRANCH_NAME=$</span>

          <span class="s">BRANCH_NAME=""</span>
          <span class="s">SERVICE_NAME=""</span>

          <span class="s">if [[ $FULL_BRANCH_NAME == "main" || $FULL_BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">BRANCH_NAME="$FULL_BRANCH_NAME"</span>
            <span class="s">SERVICE_NAME="$FULL_BRANCH_NAME"</span>
          <span class="s">else</span>
            <span class="s"># Split the branch name by "/"</span>
            <span class="s">IFS='/' read -ra BRANCH_PARTS &lt;&lt;&lt; "$FULL_BRANCH_NAME"</span>

            <span class="s"># Check if the length of the array is greater than 1</span>
            <span class="s">if [ "${#BRANCH_PARTS[@]}" -gt 1 ]; then</span>
              <span class="s"># Assign the second part as the service name</span>
              <span class="s">BRANCH_NAME=${BRANCH_PARTS[0]}</span>
              <span class="s">SERVICE_NAME=${BRANCH_PARTS[1]}</span>
            <span class="s">else</span>
              <span class="s"># If the length is 1, raise an error</span>
              <span class="s">echo "[Error] Branch name does not contain a valid service name."</span>
              <span class="s">echo "Please check the branch name and try again."</span>
              <span class="s">echo "You can change the branch name by running the following command:"</span>
              <span class="s">echo "git branch -m &lt;new-branch-name&gt;"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
          <span class="s">fi</span>

          <span class="s">echo "BRANCH_NAME=$BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "SERVICE_NAME=$SERVICE_NAME" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "FULL_BRANCH_NAME=$FULL_BRANCH_NAME" &gt;&gt; $GITHUB_ENV</span>
<span class="s">...</span>
</code></pre></div></div><p>このように抽出したブランチ名とサービス名を使って、次のようにブランチ名とサービス名が有効か確認しています。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check Branch Name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">BRANCH_NAMES=("dependabot" "hotfix" "release" "review" "feature" "fix" "sub-feature")</span>
          <span class="s">SERVICE_NAMES=("npm_and_yarn" "github_actions" "SERVICE_1" "SERVICE_2" "template" "components" "config" "common")</span>

          <span class="s">if [[ $BRANCH_NAME == "main" || $BRANCH_NAME == "develop" ]]; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">elif printf '%s\n' "${BRANCH_NAMES[@]}" | grep -qx "${BRANCH_NAME}" &amp;&amp; printf '%s\n' "${SERVICE_NAMES[@]}" | grep -qx "${SERVICE_NAME}"; then</span>
            <span class="s">echo "Branch name is valid."</span>
          <span class="s">else</span>
            <span class="s">echo "[Error] Branch name must contain valid branch names and service names."</span>
            <span class="s">echo "- Current branch: $BRANCH_NAME"</span>
            <span class="s">echo "- Branch names: main develop ${BRANCH_NAMES[@]}"</span>
            <span class="s">echo "- Service names: ${SERVICE_NAMES[@]}"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
<span class="s">...</span>
</code></pre></div></div><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="ブランチ名の変更">ブランチ名の変更</h2><p>このGitHub Actionsを使って、事前に定義した規則に合わないブランチ名でPRを作成するとエラーが発生します。この時は次のようにブランチ名を変更します。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;current-branch-name&gt;
git branch <span class="nt">-m</span> &lt;new-branch-name&gt;
</code></pre></div></div><p>また、次のように変更することができます。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch <span class="nt">-m</span> &lt;current-branch-name&gt; &lt;new-branch-name&gt;
</code></pre></div></div><p>このようにブランチ名を変更した場合、新しいPRを作成し、古いPRを閉じる必要があります。</p><h2 id="git-hooks">Git hooks</h2><p>間違ったブランチ名を使った場合、このGitHub Actionsで確認が可能ですが、PRを作成しないと確認ができません。また、ブランチ名が間違っている場合は、既存のPRを閉じて新しいPRを作成する必要があります。</p><p>このような場合、Git hooksを使うとPRを作成する前にブランチ名を確認することができて、不要な作業を減らすことができます。</p><h3 id="ブランチ名の確認scriptの作成">ブランチ名の確認scriptの作成</h3><p>ブランチ名を確認するscriptを作成するために、<code class="language-plaintext highlighter-rouge">scripts/check-branch-name.sh</code>ファイルを作成し、次のように修正します。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

<span class="nv">pattern</span><span class="o">=</span><span class="s1">'^(dependabot|hotfix|release|review|feature|fix|sub-feature)/(npm_and_yarn|github_actions|SERVICE_1|SERVICE_2|template|components|config|common)/.*'</span>
<span class="nv">errorMessage</span><span class="o">=</span><span class="s1">'Invalid branch name. Please follow the correct naming convention.'</span>

<span class="k">if</span> <span class="o">!</span> git rev-parse <span class="nt">--is-inside-work-tree</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Error: Not inside Git working tree."</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">branches</span><span class="o">=</span><span class="si">$(</span>git branch | <span class="nb">grep</span> <span class="s1">'^\*'</span> | <span class="nb">sed</span> <span class="s1">'s/^\* //'</span><span class="si">)</span>

<span class="k">if </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-Eq</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[32mPassed</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
<span class="k">else
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[31mResult: failed</span><span class="se">\n</span><span class="s2">Error Msg: %s</span><span class="se">\n</span><span class="s2">Branch Name: %s</span><span class="se">\n</span><span class="s2">Pattern: %s</span><span class="se">\0</span><span class="s2">33[0m</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$branches</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$pattern</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$errorMessage</span><span class="s2">"</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>
</code></pre></div></div><h3 id="huskyの設定">Huskyの設定</h3><p>Huskyを使ってGit hooksを設定する場合、次のように<code class="language-plaintext highlighter-rouge">.husky/pre-commit</code>ファイルを修正します。</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">validation</span><span class="w"> </span><span class="err">branch</span><span class="w"> </span><span class="err">name</span><span class="w">
</span><span class="err">.</span><span class="w"> </span><span class="s2">"$(dirname -- "</span><span class="err">$</span><span class="mi">0</span><span class="s2">")/scripts/validateBranchName.sh"</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">Run</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span><span class="err">yarn</span><span class="w"> </span><span class="err">lint-staged</span><span class="w">
</span></code></pre></div></div><p>この時、先に作成した<code class="language-plaintext highlighter-rouge">check-branch-name.sh</code>ファイルは<code class="language-plaintext highlighter-rouge">.husky/scripts/validateBranchName.sh</code>に移動させる必要があります。</p><h3 id="lefthookの設定">Lefthookの設定</h3><p>Lefthookを使ってGit hooksを設定する場合、次のように<code class="language-plaintext highlighter-rouge">.lefthook.yml</code>ファイルを修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pre-push</span><span class="pi">:</span>
  <span class="na">scripts</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">validateBranchName.sh"</span><span class="err">:</span>
      <span class="na">runner</span><span class="pi">:</span> <span class="s">bash</span>
</code></pre></div></div><p>この時、先に作成した<code class="language-plaintext highlighter-rouge">check-branch-name.sh</code>ファイルは<code class="language-plaintext highlighter-rouge">.lefthook/pre-commit/validateBranchName.sh</code>に移動させる必要があります。</p><h2 id="完了">完了</h2><p>これでGitHub Actionsを使ってPRを作った時、ブランチ名をチェックする方法について説明しました。また、Git hooksを使ってPRを作成する前にブランチ名を確認する方法についても説明しました。</p><p>もし、私のようにプロジェクトでブランチ名が重要な役割を果たす場合は、このGitHub ActionsとGit hooksを使ってブランチ名を確認してみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actionsを使ってPRを作った時、ブランチ名をチェックする方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">[GitHub Actions] PRに自動でAssigneesを追加する</title><link href="https://deku.posstree.com/github_actions/auto-assing-assigness" rel="alternate" type="text/html" title="[GitHub Actions] PRに自動でAssigneesを追加する"/><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-30T11:30:34+09:00</updated><id>https://deku.posstree.com/github_actions/auto-assing-assigness-ja</id><content type="html" xml:base="https://deku.posstree.com/github_actions/auto-assing-assigness"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#github-actions%E7%94%9F%E6%88%90">GitHub Actions生成</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>通常、開発が完了した後、開発を担当した開発者がGitHubでPR(Pull Request)を作成し、自分自身を<code class="language-plaintext highlighter-rouge">Assignees</code>に追加します。しかし、毎回PRを作成するたびに<code class="language-plaintext highlighter-rouge">Assignees</code>に自分自身を追加するのは手間です。</p><p>このブログポストでは、GitHub Actionsを使ってPRを作成するたびに自動的に<code class="language-plaintext highlighter-rouge">Assignees</code>にPRを作った開発者を追加する方法について説明します。</p><h2 id="github-actions生成">GitHub Actions生成</h2><p>PRに自動的に<code class="language-plaintext highlighter-rouge">Assignees</code>を追加するGitHub Actionsを作成するために<code class="language-plaintext highlighter-rouge">.github/workflows/auto-assign-assignees.yml</code>ファイルを作成し、次のように修正します。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Assign assignees</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p>このGitHub Actionsをもう少し詳しく見ていきましょう。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">opened</span>
<span class="nn">...</span>
</code></pre></div></div><p>このGitHub ActionsはPRが作成されたときに実行されます。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">if</span><span class="err">:</span> <span class="s">github.event.pull_request.user.login != 'dependabot[bot]'</span>
    <span class="s">...</span>
</code></pre></div></div><p>私はGitHubでDependabotを使っています。Dependabotが生成したPRのAssigneesにDependabotを追加できないので、Dependabotが生成したPRにはAssigneesを追加しないように設定しました。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">assign</span><span class="pi">:</span>
    <span class="s">...</span>
    <span class="s">steps</span><span class="err">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set assignees</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v7</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { owner, repo } = context.repo</span>
            <span class="s">const prNumber = context.payload.pull_request.number</span>

            <span class="s">const response = await github.rest.issues.get({</span>
              <span class="s">owner,</span>
              <span class="s">repo,</span>
              <span class="s">issue_number: prNumber,</span>
            <span class="s">})</span>
            <span class="s">const { assignees } = response.data</span>

            <span class="s">if (assignees.length === 0) {</span>
              <span class="s">await github.rest.issues.addAssignees({</span>
                <span class="s">owner: owner,</span>
                <span class="s">repo: repo,</span>
                <span class="s">issue_number: prNumber,</span>
                <span class="s">assignees: [context.actor]</span>
              <span class="s">})</span>
            <span class="s">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">GitHub</code>が提供するGitHub Actionsを使ってJavaScriptコードでPRを作成する開発者(<code class="language-plaintext highlighter-rouge">context.actor</code>)を<code class="language-plaintext highlighter-rouge">Assignees</code>に追加するコードを書きました。</p><h2 id="完了">完了</h2><p>これでPRを作成するたびに自動的に<code class="language-plaintext highlighter-rouge">Assignees</code>にPRを作った開発者を追加するGitHub Actionsを作成する方法について説明しました。皆さんもこのGitHub Actionsを使って手動で設定していたAssigneesを自動的に設定してみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="github_actions"/><summary type="html"><![CDATA[GitHub Actionsを使ってPRに自動でAssigneesを追加する方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/github_actions/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">専門家になるための意図的な訓練</title><link href="https://deku.posstree.com/essay/deliberate-practice-to-become-expert/" rel="alternate" type="text/html" title="専門家になるための意図的な訓練"/><published>2024-08-26T00:00:00+09:00</published><updated>2024-09-17T11:48:36+09:00</updated><id>https://deku.posstree.com/essay/deliberate-practice-to-become-expert-ja</id><content type="html" xml:base="https://deku.posstree.com/essay/deliberate-practice-to-become-expert/"><![CDATA[<p>私たちは一生歯磨きをするし、一生呼吸をしますが、歯磨きの専門家でも、呼吸の専門家でもなりません。</p><p>このように一生何かをしていても、そのことに対する専門家になれない理由は、その仕事をする動機とやった行動に対するフィードバックが不足しているためです。</p><p>何かの専門家になるためには専門家になりたい部分で<code class="language-plaintext highlighter-rouge">スキルを向上させようとする動機</code>を持って、スキル向上活動に対する<code class="language-plaintext highlighter-rouge">適切なタイミングで具体的なフィードバック</code>を受けて、これを継続的に繰り返す必要があります。</p><p>意図的訓練はこのような動機とフィードバックを通じて専門性を向上させる方法です。</p><h2 id="妥当性とフィードバック">妥当性とフィードバック</h2><p>専門性が形成されるためには動機とフィードバック以外にも<code class="language-plaintext highlighter-rouge">妥当性</code>が必要です。妥当性はある作業に因果関係と規則性が存在し、結果に対する予測可能性があることを意味します。</p><p>このように妥当性が高い領域は自分がした行動に対する結果を確認でき、これが作業に対するフィードバックになります。</p><p>妥当性とフィードバックがある環境では自分がした行動に対する結果を知ることができ、これを通じて学習の機会が与えられます。</p><blockquote><p>空港のセキュリティチェックの調査員は、自分が今日どれだけミスをしたかを知る方法がありません。バッグからナイフや液体物質をどれだけ見つけたかは分かっても、どれだけ見逃したかはわかりません。</p></blockquote><p>空港セキュリティチェックの調査員は妥当性とフィードバックがある環境ではないため、専門家になることができません。このようにフィードバックが不足している環境ではどれだけ長く働いても専門家になることはできません。</p><p>ある仕事では専門性が形成される作業と専門性を形成するのが難しい作業の両方が存在することもあります。</p><blockquote><p>医師が患者を診断するとき、間違った診断をしたかどうかを知る方法はありません。そのためこの部分では専門性を向上させるのが難しいです。しかし、手術をするときは手術後患者の状態を見て手術がうまくいったか判断できるため、手術を通じて専門性を向上させることができます。</p></blockquote><p>私が所属している業界が妥当性とフィードバックが不足している業界であるため専門性向上を諦めてはいけません。現在の働き方を変えて妥当性とフィードバックを高めれば十分に専門家になることができます。</p><p>妥当性を高めるためには業務で変数を設定し、その変数を修正する実験をしながら規則性と因果関係を見つけようとする努力をしなければなりません。</p><p>フィードバックを高めるためには同僚や上司、顧客からまたは自分がする業務から直接フィードバックを受けようと努力しなければなりません。私のような開発者の場合は同僚や上司からコードレビューを受けたり、静的解析ツールやテストコードを通じてフィードバックを受けることができます。</p><h2 id="難易度">難易度</h2><p>実力を高めるためには<code class="language-plaintext highlighter-rouge">意図的訓練</code>が重要です。1万時間の法則のように訓練の量的な部分を強調する場合は多いですが、質的な部分を強調する場合は少ないです。</p><p>意図的訓練の必須条件の一つは適切な<code class="language-plaintext highlighter-rouge">難易度</code>です。意図的訓練がされるためには自分の実力と作業の難易度が似ていなければなりません。これはミハイ・チクセントミハイ(Mihaly Csikszentmihalyi)の没入理論とも一致します。</p><picture><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.avif" type="image/avif"/><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.webp" type="image/webp"/><img src="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/flow.jpg" alt="Deliberate practice to become an expert: Flow"/></picture><p>横軸はその作業に対して自分が感じる自己実力を言い、縦軸はその作業に対して自分が感じる難易度です。</p><p><code class="language-plaintext highlighter-rouge">Boredom ゾーン</code>の仕事は実力が作業難易度より高い領域です。この仕事をすると最初は楽な仕事を担当するため、とても良いと思いますが、少し経つと仕事に対して<code class="language-plaintext highlighter-rouge">退屈</code>を感じるようになります。</p><p><code class="language-plaintext highlighter-rouge">Anxiety ゾーン</code>は実力より難易度が高い領域です。この領域ではその作業に対して知らないことが多く、自分の実力で解決できない<code class="language-plaintext highlighter-rouge">不安</code>や<code class="language-plaintext highlighter-rouge">恐怖</code>を感じるようになります。</p><p><code class="language-plaintext highlighter-rouge">Apathy-Flow ゾーン</code>は難易度と実力がほぼ同じ領域です。ミハイ・チクセントミハイはこの部分で人間が<code class="language-plaintext highlighter-rouge">没入</code>を経験すると言います。人間が没入状態になると最高レベルの集中力を示し、パフォーマンスや学習能力が最大になることができると言います。そしてその時最高レベルの幸福感を経験すると言います。</p><p>言語学者であるクラッシェン(Stephen Krashen)の入力仮説(i+1 理論)では、学習者の言語レベルをiとすると、ちょうど一段階高いi+1 レベルの入力が与えられたときにのみ言語能力が有意に向上すると言います。</p><p>教育学では認知負荷理論(Cognitive load theory)という理論があります。この理論は学習時に不要に認知的な負担を与えると何もかも正しく学習するのが難しいという理論です。例えば微積分のように難しい概念を自分がよく知らない言語であるドイツ語で学ぶと、微積分自体よりも他のことにエネルギーを奪われ学習効率が下がります。逆に英単語を覚えるときは母音を隠して覚えると<code class="language-plaintext highlighter-rouge">より難しくなって</code>逆に記憶が長持ちするという研究もあります。</p><p>このような研究結果を通じてわかる重要な事実は実力を向上させるためには適切な難易度が必要であるということです。</p><p>もし自分が業務時間中に不安や退屈を感じる場合、これは実力を向上させる環境にいないということです。問題はこのような環境に慣れて行動が習慣化されるとこのような認識自体もうまくいかないということです。</p><p>これは<a href="https://www.researchgate.net/publication/312624160_An_examination_of_the_practice_environments_in_figure_skating_and_volleyball_A_search_for_deliberate_practice" rel="nofollow noreferrer" target="_blank">An examination of the practice environments in figure skating and volleyball: A search for deliberate practice</a>の研究結果から確認できます。</p><blockquote><p>地域大会レベルの選手と世界大会レベルの選手の2つのグループを比較しました。まず、1日の練習が終わった後、簡単なアンケートを通じていくつかの質問をしました。その中の1つが今日の練習中トリプルアクセルを何回ほどしたと記憶しているかという質問です。2つのグループの回答には大きな違いはありませんでした。しかし、2つのグループの実際の練習シーンを録画して分析した結果、世界大会レベルの選手は地域大会レベルの選手に比べて何倍も多く、トリプルアクセルを練習していました。地域大会レベルの選手は自分たちがすでに慣れて自信を持っている’芸術的表現’などの練習に時間をさらに費やしました。その後トリプルアクセルを多く練習したと勘違いしました。</p></blockquote><p>この研究結果からわかるように人間は自分の置かれた環境に慣れ、慣れた環境では自己認識をうまくできなくなる。</p><h2 id="意図的訓練">意図的訓練</h2><p>私たちはミハイ・チクセントミハイの没入理論を基に意図的訓練をすることができます。</p><picture><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.avif" type="image/avif"/><source srcset="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.webp" type="image/webp"/><img src="/assets/images/category/essay/2024/deliberate-practice-to-become-expert/deliberate-practice.jpg" alt="Deliberate practice to become an expert: Deliberate practice"/></picture><p>上の図のように私たちは合計4つの意図的訓練をすることができます。</p><ul><li><code class="language-plaintext highlighter-rouge">A1</code>: 実力を下げる</li><li><code class="language-plaintext highlighter-rouge">A2</code>: 難易度を上げる</li><li><code class="language-plaintext highlighter-rouge">B1</code>: 難易度を下げる</li><li><code class="language-plaintext highlighter-rouge">B2</code>: 実力を上げる</li></ul><p>この意図的訓練は実力を向上させるためには必ず行わなければなりません。そうでないと自分の実力は向上せず、フィギュアスケートの研究結果のように実力が向上しているという錯覚に陥る可能性があります。</p><h3 id="a1-実力を下げる">A1: 実力を下げる</h3><p>作業の難易度はそのままで、自分の実力を下げる意図的訓練方法です。例えば、体力トレーニングをするときに、腕や足に砂袋をつけて運動することです。</p><p>私のように開発者であれば、自分の開発を効率的にしたり、より便利にするためのツールを使わないことで、意図的訓練を行うことができます。例えば、ESLintやPrettierなどの静的コード解析ツールをリアルタイムで使用せずにコーディングするか、よく使うIDEやテキストエディタ以外のツールを使用するか、マウスをよく使う場合はキーボードだけで開発するか、デバッガを使用せずに開発するなど、開発の便利さや効率性のためのツールを使わないようにして、自分のスキルを下げて意図的訓練を行うことです。ツールがいつもしてくれたことを自分の力だけで解決しなければならないため、以前よりも多くの考えをするようになり、集中力が高まります。</p><h3 id="a2-難易度を上げる">A2: 難易度を上げる</h3><p>自分の実力はそのままで、作業の難易度を上げる意図的訓練方法です。</p><blockquote><p>1965年にサンフランシスコでの戦いがブルース・リーがウェイトトレーニングに弾みをつけるきっかけとなった。当時、ブルース・リーは人々にクンフを教え始めた時期であった。伝統的な武術をしていた人の一人がブルース・リーが西洋人を教えると聞いて挑戦しに来て、ブルース・リーの妻リンダ・リーがそのシーンを目撃した。”約3分間続いた。ブルースはその人を地面に倒して言った。 ‘今、降参しますか？’ するとその人が ‘降参します’ と言った。そうして彼ら一行はサンフランシスコに戻った。しかし、ブルースは非常に怒っていた。3分以内にその人を倒せなかったからだ。それからだった。ブルースは自分の身体的健康レベルと武術スタイルに疑問を抱き始めた” - How Bruce Lee Changed the World, Discovery Channel, 2009.</p></blockquote><p>ブルース・リーのように、自分の実力が高すぎると相手との戦いが簡単になることがあります。このとき、<code class="language-plaintext highlighter-rouge">3分以内に勝つ</code>など自分だけの制約を追加することで作業の難易度を上げることができます。</p><p>優れたプログラマーはこの方法をよく使っています。例えば、1日で開発するように言われた仕事を1時間で完了する方法を考えるとか、UIの反応速度を速くするためにプログラムをリファクタリングするとか、毎日1つのバグや問題を見つける代わりに2つを見つけるように努力するとか、新しい言語でコーディングするなど、意図的訓練を行うことができます。</p><p>他の方法では、公式的にはしなくてもよい業務を自分の意志で追加することがあります。例えば、自分の業務を改善するためにリファクタリングを行ったり、自動化テストを追加したり、自分だけのツール(方法)を開発することです。</p><p>A2の方法では特に自分だけのツールや方法を作ることが非常に重要です。認知心理学では相手の専門性を素早く把握する方法の1つとして、<code class="language-plaintext highlighter-rouge">他の人よりも仕事をより効率的に、効果的に行うために自分だけのツールや方法</code>があるのか質問する方法があります。よくある繰り返しパターンを把握し、分析して時間が足りない中でも時間を作ってツールを考案し、作成しなければなりません。このようにツールを作ると既存の難易度よりも高くなり、これによりスキルが向上します。また、このように作成したツールが自分の業務をより効率的で効果的にしてくれるため、自分の専門性を高めるのに大きな助けになります。</p><h3 id="b1-難易度を下げる">B1: 難易度を下げる</h3><p>難易度が実力よりも高い場合、難易度を下げることで意図的訓練を行う方法です。高い難易度の課題を自分の能力で作れる代替機能を開発するか、より簡単な小さな課題に分割して処理する方法です。</p><p>この方法を使うときに注意すべき点があります。実力と難易度は常に変化するということです。昨日までうまくいかなくて悩んでいた問題が今日急にうまくいくようになったり、簡単な課題と思っていたがバグが発生して難易度が急激に上昇することもあります。また、自分が試みた方法が間違っていて難易度をあまりにも高くしてしまうこともあります。</p><p>そのため、この方法は柔軟に使う必要があります。作業難易度が高くて低い難易度に分割したら、それが簡単すぎて退屈を感じる場合、また難易度を上げたり、実力を下げたりする必要があります。作業をする際に実力が上がって難易度が簡単になった場合はこれに合わせて再調整する必要があります。</p><h3 id="b2-実力を上げる">B2: 実力を上げる</h3><p>実力より難易度が高い場合、実力を上げる意図的訓練方法です。</p><p>実力を上げるためには次のような方法があります。</p><ul><li>本</li><li>スタディグループ</li><li>教育</li></ul><p>しかし、この方法は長期的な方法です。現在の難易度が自分の実力より高くて、実力を上げるためには時間がかかりすぎます。そしたら、短期的に実力を上げる方法には何がありますでしょうか？</p><p>短期的に実力を上げるためには、社会的アプローチ、ツール的アプローチ、内観的アプローチを使うことができます。</p><p>社会的アプローチは自分よりも優れた専門家の助けを借りることです。優れたメンバーにペアプログラミングを提案したり、インターネットで検索したり、コミュニティに投稿して助けを求めたり、公式ドキュメントを参照する方法などがこれに該当します。</p><p>ツール的アプローチはツールの助けを借りることです。より良いデバッガ、自動統合ツール、コード分析ツール、オープンソースの使用などがこれに該当します。</p><p>内観的アプローチは似てる問題を解決した経験を思い出して比喩的に問題を解決する方法です。</p><h2 id="リーダーができること">リーダーができること</h2><p>リーダーはチームメンバーに実力に合う適切な業務を与え、チームメンバーの状態を把握しながら、前述の意図的訓練方法を適切に使えるように助ける必要があります。しかし、これは理想的な状態であり、これを実行することは非常に難しいです。</p><p>そのため、リーダーはチームメンバーが個人でこのような意図的な訓練の方法を実行できる環境と能力を作ることが重要です。</p><h2 id="日常での意図的訓練">日常での意図的訓練</h2><p>意図的な訓練は業務だけでなく、日常生活でも適用できます。このように一つの領域での教訓を他の領域に適用することを心理学では学習転移と言います。</p><p>皆さんもこのような意図的訓練を業務や日常生活に適用して、業務の専門家、生活の専門家になってみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="essay"/><summary type="html"><![CDATA[一生同じことを繰り返しても専門家にはなれません。専門家になるためには意図的な訓練が必要です。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/essay/2024/deliberate-practice-to-become-expert/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/essay/2024/deliberate-practice-to-become-expert/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">VSCodeでMonorepo用のESLint設定</title><link href="https://deku.posstree.com/environment/vscode/eslint-configuration-for-monorepo" rel="alternate" type="text/html" title="VSCodeでMonorepo用のESLint設定"/><published>2024-08-22T00:00:00+09:00</published><updated>2024-08-27T20:01:47+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-eslint-configuration-for-monorepo-ja</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/eslint-configuration-for-monorepo"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#vscode%E3%81%AEcurrent-working-directory">VSCodeのCurrent working directory</a></li><li><a href="#vscodesettingsjson%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E7%B7%A8%E9%9B%86">vscode/settings.jsonファイルの編集</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>Monorepo環境では、複数のパッケージを1つのリポジトリで管理するため、各パッケージごとに個別のESLint設定が必要な場合があります。 このとき、ESLintがどのディレクトリを基準に動作するかを決定することが重要です。</p><p>今回のブログポストでは、Visual Studio Code（VSCode）でMonorepoプロジェクトでESLintのCurrent Working Directory（CWD）を設定する方法について説明します。</p><h2 id="vscodeのcurrent-working-directory">VSCodeのCurrent working directory</h2><p>VSCodeでは特別な設定をしない限り、ESLintはルートフォルダにあるESLint設定ファイルを基準に動作します。 しかし、Monorepoプロジェクトでは、各プロジェクトごとにESLint設定ファイルがあるかもしれません。</p><p>このとき、VSCodeでESLintのCurrent Working Directory（CWD）を設定すると、ESLintはそのディレクトリを基準に動作するようになります。</p><h2 id="vscodesettingsjsonファイルの編集">.vscode/settings.jsonファイルの編集</h2><p>次はVSCodeでESLintのCurrent Working Directory（CWD）を設定する方法です。</p><ol><li>mode設定</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"auto"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>このように設定すると、VSCodeはESLint設定ファイルがあるディレクトリを自動的に検索してCWDとして設定します。</p><ol><li>pattern設定</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"./packages/*/"</span><span class="w"> </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Glob</code>パターンでCWDとなるディレクトリを設定することもできます。</p><ol><li>ディレクトリ指定設定</li></ol><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="err">...</span><span class="w">
  </span><span class="nl">"eslint.workingDirectories"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"./packages/package1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"./packages/package2"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p>このように配列で特定のディレクトリを指定することもできます。</p><h2 id="完了">完了</h2><p>これでVSCodeでMonorepoプロジェクトを開発する際、ESLintのCurrent Working Directory（CWD）を設定する方法について説明しました。</p><p>私は<code class="language-plaintext highlighter-rouge">"mode": "auto"</code>を設定して使っています。 特に問題がない場合は、この設定を使うことをお勧めします。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[Monorepoプロジェクトを開発する際、VSCodeでESLintを設定する方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/eslint-configuration-for-monorepo/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">[エッセイ] AI時代で生き残るための学習方法</title><link href="https://deku.posstree.com/essay/how-to-survive-in-ai-era/" rel="alternate" type="text/html" title="[エッセイ] AI時代で生き残るための学習方法"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-25T20:50:59+09:00</updated><id>https://deku.posstree.com/essay/how-to-survive-in-ai-era-ja</id><content type="html" xml:base="https://deku.posstree.com/essay/how-to-survive-in-ai-era/"><![CDATA[<p>次の条件はAIが学習しやすい条件です。</p><ol><li>目標(Goal)が明確で客観的で静的です。</li><li>毎回選択する行動と選択の種類が有限です。</li><li>毎回自分の選択によって目標にどれだけ近づいたかを知ることができます。</li><li>主に予想できない外部要素の影響がない閉じたシステムです。</li><li>目標達成のための選択と結果に関するデータが多いです。</li></ol><p>このような状況はAIだけでなく、人間も学習しやすい条件です。</p><p>ジェームズ・シャントー(James Shanteau)が発表した<a href="https://www.researchgate.net/publication/4815960_Competence_in_Experts_The_Role_of_Task_Characteristics" rel="nofollow noreferrer" target="_blank">Competence in Experts: The Role of Task Characteristics</a>研究によると、フィードバックが与えられ、作業が繰り返され、客観的な分析が可能な場合にその職業で専門性がよく現れると言います。</p><p>しかし、このような専門性がよく現れる職業が現在はAIが学習しやすい条件を持っていると見ることができます。</p><p>人間が学習しやすい環境はAIも学習しやすい環境であるため、このような職業はいつかAIに席を取られるかもしれないです。そのため、AI時代で生き残るためには、学習しにくい環境で学習しにくいトピックを選ぶ必要があります。</p><p>学習しにくい条件は次のようになります。</p><ol><li>目標が曖昧で主観的で動的です。</li><li>毎回選択できる行動と選択の種類が無限です。</li><li>毎回自分の選択によって目標にどれだけ近づいたかを知ることができない。</li><li>主に予想できない外部要素に影響を受ける開かれたシステムです。</li><li>目標達成のための選択と結果に関するデータが少ないです。</li></ol><p>このような条件は人間が学習しにくく、特にAIが学習するにはさらに難しいです。</p><p>また、独創性、社会的感受性、交渉、説得、他人を助けたり世話をするなどが要求されるレベルの高い職業はAIが置き換えることが難しいです。</p><ul><li>独創性(Originality): 与えられたトピックや状況に対して特異な考えを出し、または問題を解決する創造的な方法を作り出す。</li><li>社会的感受性(Social preceptiveness): 他人の反応を察知し、その人々がなぜそのように反応しているかを理解する。</li><li>交渉(Negotiation): 人々を和解させ、互いの違いを調整しようと努力する。</li><li>説得(Persuasion): 他の人々の心や行動を変えるよう説得する。</li><li>他人を助けたり世話をする(Assisting and caring for others): 個人的な助け、治療、感情的支持、または同僚、顧客、患者などの他人に対するその他の個人的な助けを提供すること。</li></ul><p>私は開発者です。開発者の分野を見てみると、コンピュータプログラマーはAIが置き換えやすい職業であり、ソフトウェア開発者はAIが置き換えにくい職業です。この2つの違いは独創性、交渉、説得力に違いがあります。</p><ul><li>コンピュータプログラマー: 他の人が与えたスペック通りに開発することを主業務とし、その過程で交渉、説得が大きく必要ではない。</li><li>ソフトウェア開発者: ソフトウェアを作る際、何を作るかを考えて設計する部分が含まれ、その過程で他人と相互作用する業務が多い。</li></ul><p>これだけでなく、現在の給与が低い職業ほどAIがその職業を置き換える可能性が高いです。</p><p>自分のキャリアを作る際、AIが置き換え可能かを確認する必要があります。AIが置き換え可能なキャリアの場合、競争力がなく、あるいは職業自体がなくなる可能性があります。AI時代で生き残るためには、AIが置き換えするのが難しい部分を学習し、成長できるよう努力する必要があります。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="essay"/><summary type="html"><![CDATA[AI時代でAIが置き換えることが難しいキャリアを作るための学習方法について見ていきましょう。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/essay/2024/how-to-survive-in-ai-era/background.png" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">VSCode Incoming/Outgoing changes graphを非表示にする</title><link href="https://deku.posstree.com/environment/vscode/incoming-outgoing-changes-graph" rel="alternate" type="text/html" title="VSCode Incoming/Outgoing changes graphを非表示にする"/><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-16T10:52:53+09:00</updated><id>https://deku.posstree.com/environment/vscode/vscode-incoming-outgoing-changes-graph-ja</id><content type="html" xml:base="https://deku.posstree.com/environment/vscode/incoming-outgoing-changes-graph"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</a></li><li><a href="#incomingoutgoing-changes-graph%E3%82%92%E9%9D%9E%E8%A1%A8%E7%A4%BA%E3%81%AB%E3%81%99%E3%82%8B">Incoming/Outgoing changes graphを非表示にする</a></li><li><a href="#%E7%A2%BA%E8%AA%8D">確認</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>2024年7月に更新されたVisual Studio Code(VSCode)のGit機能の1つである<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>は、GitのHistoryをグラフで表示する機能です。</p><ul><li><a href="https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph" rel="nofollow noreferrer" target="_blank">https://code.visualstudio.com/updates/v1_92#_incomingoutgoing-changes-graph</a></li></ul><p>この機能が追加された後、<code class="language-plaintext highlighter-rouge">Source Control</code>パネルを開くと<code class="language-plaintext highlighter-rouge">Source Control</code>パネルが表示される速度が遅くなる問題が発生しました。</p><p>今回のブログポストでは<code class="language-plaintext highlighter-rouge">Source Control</code>パネルの速度が遅くなる問題を解決するためにVSCodeの<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>を非表示にする方法について説明します。</p><h2 id="incomingoutgoing-changes-graph">Incoming/Outgoing changes graph</h2><p>VSCodeで<code class="language-plaintext highlighter-rouge">Source Control</code>パネルを開くと、以下のように<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>が表示されます。</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/incoming-outgoing-changes-graph.png" alt="VSCode source control - incoming outgoing changes graph"/></picture><p>この機能が追加された後、<code class="language-plaintext highlighter-rouge">Source Control</code>パネルを開くと<code class="language-plaintext highlighter-rouge">Source Control</code>パネルが表示される速度が遅くなる問題が発生しました。</p><h2 id="incomingoutgoing-changes-graphを非表示にする">Incoming/Outgoing changes graphを非表示にする</h2><p>幸いにもVSCodeには<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>を非表示にする設定があります。</p><p>VSCode設定で<code class="language-plaintext highlighter-rouge">scm.showHistoryGraph</code>を検索すると、以下のように<code class="language-plaintext highlighter-rouge">SCM: Show History Graph</code>を見つけることができます。</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/show-history-graph-setting.png" alt="VSCode source control - show history graph setting"/></picture><p>この設定のチェックを解除することで<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>を非表示にすることができます。</p><h2 id="確認">確認</h2><p>この設定のチェックを解除して再度<code class="language-plaintext highlighter-rouge">Source Control</code>パネルを開いてみると、<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>が非表示になっていることを確認できます。</p><picture><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/incoming-outgoing-changes-graph/hide-incoming-outgoing-changes-graph.png" alt="VSCode source control - hide incoming outgoing changes graph"/></picture><h2 id="完了">完了</h2><p>これでVSCodeの<code class="language-plaintext highlighter-rouge">Incoming/Outgoing changes graph</code>を非表示にする方法について説明しました。私のように<code class="language-plaintext highlighter-rouge">Source Control</code>パネルが遅くなる問題が発生した場合は、この方法を使用して問題を解決してみてください。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[VSCodeに2024年7月に新たに追加されたGitのIncoming/Outgoing changes graph機能を非表示にする方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/incoming-outgoing-changes-graph/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">ウェブキャッシュ(Web cache)とAWS S3、CloudFront</title><link href="https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront" rel="alternate" type="text/html" title="ウェブキャッシュ(Web cache)とAWS S3、CloudFront"/><published>2024-08-15T00:00:00+09:00</published><updated>2024-08-21T12:10:16+09:00</updated><id>https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront-ja</id><content type="html" xml:base="https://deku.posstree.com/environment/web/cache-and-aws-s3-cloudfront"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#%E3%82%A6%E3%82%A7%E3%83%96%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E8%AA%95%E7%94%9F%E8%83%8C%E6%99%AF">ウェブキャッシュの誕生背景</a></li><li><a href="#%E3%82%A6%E3%82%A7%E3%83%96%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5">ウェブキャッシュ</a><ul><li><a href="#cdncontents-delivery-network">CDNContents Delivery Network</a></li><li><a href="#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5browser-cache">ブラウザキャッシュBrowser cache</a></li></ul></li><li><a href="#%E3%82%A6%E3%82%A7%E3%83%96%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E5%8B%95%E4%BD%9C%E6%96%B9%E6%B3%95">ウェブキャッシュの動作方法</a></li><li><a href="#%E3%82%A6%E3%82%A7%E3%83%96%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E8%A8%AD%E5%AE%9A">ウェブキャッシュの設定</a></li><li><a href="#aws-s3%E3%81%A8cloudfront">AWS S3とCloudFront</a></li><li><a href="#aws-s3%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E8%A8%AD%E5%AE%9A">AWS S3キャッシュ設定</a></li><li><a href="#github-actions">GitHub Actions</a></li><li><a href="#stale-while-revalidate%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E7%84%A1%E4%B8%AD%E6%96%AD%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">stale-while-revalidateを使った無中断デプロイ</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>ウェブ開発においてキャッシュ(Cache)は重要な役割を果たします。キャッシュを通じてウェブサービスのパフォーマンスを向上させることができ、ユーザーエクスペリエンスを改善することができます。今回のブログポストでは、ウェブ開発におけるキャッシュ(Cache)について説明をして、AWS S3に静的ファイルでウェブサービスを提供する際にキャッシュを適用する方法について説明します。</p><h2 id="ウェブキャッシュの誕生背景">ウェブキャッシュの誕生背景</h2><p>クライアント(PC、スマートフォン)からサーバーにある情報を取得するためにはインターネット(Internet)を使います。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/server-client-internet.png" alt="Web cache and S3 - server and client with internet"/></picture><p>クライアントとサーバーを接続するインターネットは物理的に接続されており、世界中のインターネットは海底ケーブルで接続されています。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/submarine-cable.jpg" alt="Web cache and S3 - internet submarine cable"/></picture><p>クライアントとサーバーはこのように物理的に接続されているため、もちろん距離が遠いほどデータの送受信に時間がかかることになります。</p><h2 id="ウェブキャッシュ">ウェブキャッシュ</h2><p>ウェブキャッシュは物理的に遠い場所にあるサーバーのコンテンツのうち、変更が少ないコンテンツ(静的コンテンツ: HTML、CSS、JS、画像、ビデオなど)を物理的に近い場所(サーバー)にコピーして配置することでデータの送受信の遅延を減らす技術です。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache.webp" alt="Web cache and S3 - web cache"/></picture><p>ウェブでは大きく3つのキャッシュを使用します。</p><ol><li>CDN(Contents Delivery Network)</li><li>ブラウザキャッシュ(Browser cache)</li><li>データベースキャッシュ(Database cache)</li></ol><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache with browser"/></picture><p>今回のブログポストではCDNとブラウザキャッシュについて説明します。</p><h3 id="cdncontents-delivery-network">CDN(Contents Delivery Network)</h3><p>CDNは変更が少ないコンテンツのコピーを世界中の複数の場所にあるサーバーに配置してコンテンツを提供するサービスです。</p><p>これを通じてクライアントとサーバー間の距離を縮めてデータの送受信の遅延を減らすことができます。</p><p>例えば、世界的に有名なCDNサービスである<code class="language-plaintext highlighter-rouge">Cloudflare</code>は次のように世界中にサーバーを置いています。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/cloudflare-server-list.png" alt="Web cache and S3 - cloudflare server list"/></picture><p><code class="language-plaintext highlighter-rouge">Cloudflare</code>を利用すると静的ファイルを<code class="language-plaintext highlighter-rouge">Cloudflare</code>が提供するサーバーにコピーしてクライアントと近いサーバーからコンテンツを提供することができます。</p><h3 id="ブラウザキャッシュbrowser-cache">ブラウザキャッシュ(Browser cache)</h3><p>クライアント側から見ると最も近いサーバーはクライアント自体です。ブラウザはクライアントが一度アクセスしたサイトから一部のコンテンツをクライアントストレージに保存して再度アクセスする際にこの保存されたコンテンツを使えるようにするブラウザキャッシュ機能を提供します。</p><p>Chromeブラウザの場合次の場所にキャッシュをします。</p><ul><li>Windows: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;User Name&gt;\AppData\Local\Google\Chrome\User Data\Default\Cache</code></li><li>macOS: <code class="language-plaintext highlighter-rouge">/Users/&lt;User Name&gt;/Library/Caches/Google/Chrome/Default/Cache</code></li></ul><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="ウェブキャッシュの動作方法">ウェブキャッシュの動作方法</h2><p>ウェブキャッシュがどのように動作するかについて説明します。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/web-cache-with-browser.png" alt="Web cache and S3 - web cache process"/></picture><ol><li>ユーザーがブラウザからサービスにアクセスします。</li><li>ブラウザはブラウザにキャッシュされたものがあるか確認し、キャッシュがある場合はそれを使って画面を表示します。</li><li>ブラウザにキャッシュがない場合はCDNにキャッシュがあるか確認します。CDNにキャッシュがある場合はそれを使います。</li><li>CDNにキャッシュがない場合は実際のサーバーからコンテンツを取得します。</li><li>このときCDNはキャッシュをする必要があるかどうかを確認し、キャッシュできる場合はキャッシュします。</li><li>ブラウザも同様にキャッシュできる場合はキャッシュします。</li><li>次からユーザーが同じコンテンツにアクセスする時、ブラウザとCDNでキャッシュされたコンテンツを使います。</li></ol><h2 id="ウェブキャッシュの設定">ウェブキャッシュの設定</h2><p>ブラウザとCDNはどの基準でキャッシュを設定するでしょうか？ブラウザとCDNはHTTPレスポンスヘッダーにある<code class="language-plaintext highlighter-rouge">Expires</code>、<code class="language-plaintext highlighter-rouge">Cache-Control</code>、<code class="language-plaintext highlighter-rouge">Etag</code>、<code class="language-plaintext highlighter-rouge">Last-Modified</code>などを確認してキャッシュを設定します。</p><p>HTTPレスポンスヘッダーにキャッシュを設定する方法は次のようになります。</p><ul><li>Nginxの設定</li></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
    listen 80;
    server_name example.com;

    location / {
        # Set Cache-Control
        add_header Cache-Control "max-age=3600, public";

        # Set Expires
        expires 1h;
    }
}
</code></pre></div></div><ul><li>ウェブサーバーの設定(NodeJSのExpress例)</li></ul><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Set Cache-Control</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cache-Control</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">max-age=3600, public</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// Set Expires</span>
    <span class="kd">const</span> <span class="nx">maxAgeInSeconds</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">date</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="nx">date</span><span class="p">.</span><span class="nx">setSeconds</span><span class="p">(</span><span class="nx">date</span><span class="p">.</span><span class="nx">getSeconds</span><span class="p">()</span> <span class="o">+</span> <span class="nx">seconds</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">expiryDate</span> <span class="o">=</span> <span class="nx">date</span><span class="p">.</span><span class="nx">toUTCString</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Expires</span><span class="dl">'</span><span class="p">,</span> <span class="nx">expiryDate</span><span class="p">);</span>

    <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello World!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Server is running on port 3000</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>このように設定されたHTTPレスポンスヘッダーを確認してCDNとブラウザがキャッシュを設定します。</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="aws-s3とcloudfront">AWS S3とCloudFront</h2><p>AWSのS3とCloudFrontを使って静的ウェブサイトを提供することができます。</p><ul><li>S3(Simple Storage Service): 静的ファイルを保存するサービス</li><li>CloudFront: CDNサービス</li></ul><p>S3はストレージサービスですが、静的ファイルでウェブサービスを提供するサーバー機能も提供しています。</p><p>一般的にHTML、CSS、JavaScriptで開発された静的ウェブページやReact、Vue、Angularなどのフロントエンドフレームワークで開発されたウェブアプリケーションのビルド結果をS3にアップロードしてCloudFrontを通じてサービスします。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/aws-s3-cloudfront-cache.png" alt="Web cache and S3 - AWS S3 and CloudFront cache"/></picture><p>この時、S3にアップロードしたファイル設定を通じてブラウザキャッシュとCDN(CloudFront)キャッシュを設定することができます。</p><h2 id="aws-s3キャッシュ設定">AWS S3キャッシュ設定</h2><p>キャッシュはHTTPのレスポンスヘッダーに<code class="language-plaintext highlighter-rouge">Expires</code>や<code class="language-plaintext highlighter-rouge">Cache-Control</code>を設定するため、基本的にフロントエンド側で設定することはできません。</p><p><code class="language-plaintext highlighter-rouge">CloudFront + S3</code>はサーバーがないためHTTPヘッダーを設定するサーバーコードを追加することはできません。</p><p>しかし、<code class="language-plaintext highlighter-rouge">S3</code>がサーバー機能を持っているため、S3の設定を通じてキャッシュを設定することができます。</p><p>AWSが提供するCLIツールを使ってS3にファイルをアップロードする際、次のようなコマンドを使います。この時、<code class="language-plaintext highlighter-rouge">--cache-control</code>オプションを使うことでキャッシュを設定することができます。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws s3 <span class="nb">cp</span> &lt;Target directory&gt; s3://&lt;S3 Bucket name&gt; <span class="nt">--recursive</span> <span class="nt">--exclude</span> <span class="s2">"assets/*"</span> <span class="nt">--cache-control</span> <span class="s1">'public,max-age=60,stale-while-revalidate=2592000’
</span></code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">Target directory</code>: S3にアップロードするビルド結果があるローカルフォルダのパス</li><li><code class="language-plaintext highlighter-rouge">S3 Bucket name</code>: ファイルをアップロードする対象となるS3のBucket名</li><li><code class="language-plaintext highlighter-rouge">--recursive</code>オプション: <code class="language-plaintext highlighter-rouge">aws s3 cp</code>は基本ファイル1つをコピーするコマンドなので、指定されたディレクトリのすべてのファイルをアップロードするために<code class="language-plaintext highlighter-rouge">--recursive</code>オプションを使います</li><li><code class="language-plaintext highlighter-rouge">--exclude "assets/*"</code>: アップロード除外対象の設定</li><li><code class="language-plaintext highlighter-rouge">--cache-control 'public,max-age=60,stale-while-revalidate=2592000'</code>: キャッシュ設定 <ul><li><code class="language-plaintext highlighter-rouge">max-age=60</code>: 60秒間キャッシュ</li><li><code class="language-plaintext highlighter-rouge">stale-while-revalidate</code>: <code class="language-plaintext highlighter-rouge">max-age</code>によってキャッシュが終了した場合、バックグラウンドでコンテンツを再確認してキャッシュする間、期限切れのキャッシュを最大30日間提供するように設定</li></ul></li></ul><h2 id="github-actions">GitHub Actions</h2><p>次は<code class="language-plaintext highlighter-rouge">GitHub Actions</code>を使ってS3にファイルをアップロードするコードです。</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure AWS credentials</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">aws-actions/configure-aws-credentials@v4</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">role-to-assume</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">aws-region</span><span class="pi">:</span> <span class="s">ap-northeast-1</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload file to S3</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">aws s3 rm s3://$ --recursive</span>
    <span class="s">aws s3 cp apps/dist s3://$ --recursive --exclude "assets/*" --cache-control 'public,max-age=60,stale-while-revalidate=2592000'</span>
    <span class="s">aws s3 sync apps/dist/assets s3://$/assets --cache-control 'public,max-age=60,immutable'</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">aws s3 rm</code>を使ってすべてのファイルを削除した後、<code class="language-plaintext highlighter-rouge">aws s3 cp</code>を使ってファイルをアップロードします。最後に<code class="language-plaintext highlighter-rouge">assets</code>フォルダを<code class="language-plaintext highlighter-rouge">aws s3 sync</code>を使ってアップロードします。</p><h2 id="stale-while-revalidateを使った無中断デプロイ">stale-while-revalidateを使った無中断デプロイ</h2><p>AWSのブログで紹介された使い方です。</p><ul><li><a href="https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/" rel="nofollow noreferrer" target="_blank">https://aws.amazon.com/jp/blogs/news/networking-and-content-delivery-host-single-page-applications-spa-with-tiered-ttls-on-cloudfront-and-s3/</a></li></ul><p>stale-while-revalidateを使うと中断なしにサービスバージョンを更新することができます。</p><picture><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.avif" type="image/avif"/><source srcset="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/stale-while-revalidate.png" alt="Web cache and S3 - stale-while-revalidate option for no downtime deployment"/></picture><ol><li>ユーザーがブラウザでサービスを実行します。</li><li>V1で既にサービスを利用しているユーザーは、ブラウザにstale-while-revalidateが設定されたV1のキャッシュがあるため、それを優先して使います。</li><li>ブラウザはバックグラウンドでキャッシュが終了した(max-age)コンテンツをCloudFront(CDN)に要求します。</li><li>CloudFrontはV2に更新されたキャッシュがあるため、それをブラウザに提供します。</li><li>ブラウザはCloudFrontから受け取ったコンテンツをキャッシュして次からこれを使います。</li><li>もし、CloudFrontのキャッシュも更新が必要な場合(max-age)、まずはstale-while-revalidateが設定されたV1のキャッシュをブラウザに提供した後、バックグラウンドで実際のサーバーからコンテンツを取得して自身のキャッシュを更新します。</li></ol><h2 id="完了">完了</h2><p>これでウェブキャッシュ(Web cache)について説明をして、AWS S3とCloudFrontを使って静的ファイルでウェブサービスを提供する際にキャッシュを適用する方法について説明しました。</p><p>このブログポストがウェブキャッシュの理解とAWSでウェブキャッシュを適用する際に役立つことを願います。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[ウェブ開発におけるキャッシュ(Cache)について説明をして、AWS S3とCloudFrontを使って静的ファイルでウェブサービスを提供する際にキャッシュを適用する方法について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/cache-and-aws-s3-cloudfront/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry xml:lang="ja"><title type="html">ソフトウェア開発のデプロイ戦略</title><link href="https://deku.posstree.com/environment/deployment-strategy/" rel="alternate" type="text/html" title="ソフトウェア開発のデプロイ戦略"/><published>2024-08-07T00:00:00+09:00</published><updated>2024-08-09T17:45:46+09:00</updated><id>https://deku.posstree.com/environment/deployment-strategy-ja</id><content type="html" xml:base="https://deku.posstree.com/environment/deployment-strategy/"><![CDATA[<div id="contents_list"><h2 id="section">目次</h2><ul><li><a href="#%E7%9B%AE%E6%AC%A1">目次</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#%E3%82%A4%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%82%B9%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">インプレースデプロイ</a></li><li><a href="#%E3%83%AD%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">ローリングデプロイ</a></li><li><a href="#%E3%83%96%E3%83%AB%E3%83%BC%E3%82%B0%E3%83%AA%E3%83%BC%E3%83%B3%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">ブルーグリーンデプロイ</a></li><li><a href="#%E3%82%AB%E3%83%8A%E3%83%AA%E3%82%A2%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">カナリアデプロイ</a></li><li><a href="#%E5%AE%8C%E4%BA%86">完了</a></li></ul></div><h2 id="概要">概要</h2><p>ソフトウェア開発においてデプロイ戦略はサービスを安定して運用するための方法です。デプロイ戦略にはさまざまな種類があり、それぞれの特徴に応じて適切なデプロイ戦略を選択して使う必要があります。今回のブログポストでは、デプロイ戦略の種類と使い方について説明します。</p><h2 id="インプレースデプロイ">インプレースデプロイ</h2><p>インプレースデプロイ(In-place deployment)は金融機関やゲームのアップデートなど、ユーザーに通知をしてその時間にサービスを停止してアップデートする構造です。</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/in-place.webp" alt="Deployment strategy - in place deployment"/></picture><ol><li>運用中のサーバーを停止します。</li><li>新しいアプリケーションをデプロイします。</li><li>停止したサーバーを再起動します。</li></ol><p>インプレースデプロイのメリットとデメリットは次の通りです。</p><p>メリット</p><ul><li>すべてのユーザーが常に同じバージョンのアプリケーションを使用します。</li><li>古いバージョンと新しいバージョンが同時に存在しないため、互換性の問題を考慮する必要がなく、互換性による問題が発生する可能性がありません。</li><li>デプロイするための新しいインフラが要らなく、デプロイも簡単なため、コストが安いです。</li></ul><p>デメリット</p><ul><li>サービスを一時停止する必要があります。</li><li>デプロイをした後、問題が発生してロールバックする必要がある場合、サービスを停止する必要があるため、ロールバックが難しいです。</li><li>デプロイ中に問題が発生すると、サービスの停止時間が長くなる可能性があります。</li></ul><p>金融機関のように、古いバージョンと新しいバージョンが同時に存在すると重大な問題(金銭的な問題)になるサービスや、ゲームのように新しいバージョンを使わないと新しいアイテム、マップ、ゲームシステムを使えないサービスにはインプレースデプロイを使います。</p><h2 id="ローリングデプロイ">ローリングデプロイ</h2><p>ローリングデプロイ(Rolling-update Deployment)は運用できるサーバーの数が限られている場合、インプレースデプロイと違って中断せずにデプロイする必要がある場合に使う方法です。</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/rolling-update.webp" alt="Deployment strategy - rolling update deployment"/></picture><ol><li>現在運用中のサーバーのうち1つを外部(ユーザー)からアクセスできないようにします。</li><li>アクセスがないか確認します。</li><li>アクセスを停止したサーバーに新しいアプリケーションをデプロイします。</li><li>デプロイしたサーバーを外部からアクセスできるようにします。</li><li>新しいサーバーが外部からアクセスできるか確認します。</li><li>すべてのサーバーが新しいバージョンのアプリケーションになるまで1~5を繰り返します。</li></ol><p>ローリングデプロイのメリットとデメリットは次の通りです。</p><p>メリット</p><ul><li>サービスを中断せずにデプロイできます。</li><li>複数のサーバーにデプロイするため、新しいバージョンのアプリケーションで問題がある場合、デプロイを中止したりロールバックすることができます。</li><li>複数のサーバーを最大限に活用してデプロイするため、負荷が分散されます。</li></ul><p>デメリット</p><ul><li>サーバーの数が限られている場合、サーバー1台を停止してデプロイするため、一時的に他のサーバーに負荷がかかる可能性があります。</li><li>1台ずつデプロイするため、すべてのサーバーにデプロイするまでに時間がかかります。</li><li>旧バージョンと新バージョンが同時に存在するため、互換性があるアプリケーションを開発してデプロイする必要があります。</li></ul><p>このデプロイ方法は運用資金が限られていてサーバーを増やすことができないサービスや会社で使い、中断せずにサービスを運用する時によく使います。</p><div class="in-feed-ads ads-container"><div class="ads-block ads-left"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="2718813593"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="ads-block ads-center"><ins class="adsbygoogle" style="display: block; text-align: center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7987914246691031" data-ad-slot="6492035359"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><h2 id="ブルーグリーンデプロイ">ブルーグリーンデプロイ</h2><p>ブルーグリーンデプロイ(Blue/Green Deployment)はサーバーの制限がなく、サービスを中断せずにデプロイしたい場合、よく使われる方法です。新バージョンのアプリケーションをプロダクション環境でテストしたい場合にもこの方法を使います。</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/blue-green.webp" alt="Deployment strategy - Blue green deployment"/></picture><ol><li>新バージョンをデプロイするためのサーバー(Green)を作ります。</li><li>新しく作ったサーバーに新アプリケーションをデプロイします。</li><li>新しいアクセスは新しいサーバーに流れるようにして、既存のサーバー(Blue)に新しいアクセスができないようにします。</li><li>新サーバーにアクセスする際、または新しいアプリケーションで問題が発生した場合、既存のサーバーにアクセスを流してロールバックします。</li><li>新しいサーバーのアクセスが特に問題がなければ、既存のサーバーを削除します。</li></ol><p>ブルーグリーンデプロイのメリットとデメリットは次の通りです。</p><p>メリット</p><ul><li>サービスを中断せずにデプロイできます。</li><li>新バージョンと旧バージョンのサーバーがまだ存在するため、問題があった場合、ロールバックが迅速に行えます。</li><li>新バージョンと旧バージョンの切り替えが簡単なため、プロダクション環境で新バージョンをテストすることができます。</li></ul><p>デメリット</p><ul><li>新バージョンと旧バージョンのサーバーを準備するため、一時的なコストが2倍になります。</li><li>新バージョンが問題ないか確認してから、旧バージョンを削除するため、デプロイが完了するまで時間がかかります。</li><li>デプロイを完了して前のバージョンのサーバーを削除した場合、ロールバックができません。ロールバックするためには前のバージョンをデプロイする必要があります。</li></ul><p>新バージョンと旧バージョンがが同時に存在しても問題がないサービス、デプロイ中に既存のアクセスを強制的に切断しないので、SessionやSocketなどを使ってユーザーのアクセスを管理するサービスで使います。</p><h2 id="カナリアデプロイ">カナリアデプロイ</h2><p>カナリアデプロイ(Canary Deployment)はA/Bテストや新しいバージョンの機能のフィードバックが必要な場合、サービスのバージョンアップを慎重にしたい場合、開発中の機能をプロダクション環境でテストしたい場合に使えるデプロイ方法です。</p><picture><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/avif"/><source srcset="/assets/images/category/environment/2024/deployment-strategy/canary.webp" type="image/webp"/><img src="/assets/images/category/environment/2024/deployment-strategy/canary.webp" alt="Deployment strategy - Canary deployment"/></picture><ol><li>新バージョンをデプロイするためのサーバーを準備します。</li><li>サービスアクセス中の一部を新バージョンに切り替えます。</li><li>新しいバージョンが良いと判断された場合、ユーザーのアクセスを徐々に増やします。</li><li>良くないと判断された場合、前のバージョンのサーバーにユーザーアクセスを戻します。</li><li>新しいサーバーのアクセスが特に問題がなければ、前のサーバーを削除します。</li></ol><p>カナリアデプロイのメリットとデメリットは次の通りです。</p><p>メリット</p><ul><li>A/Bテストや新しい機能の反応を観察して新しい機能を導入するかどうかを決めることができます。</li><li>ロールバックが簡単です。</li><li>モニタリングしながらデプロイできるため、より安全にデプロイできます。</li></ul><p>デメリット</p><ul><li>新しいバージョンと前のバージョンのサーバーを準備するため、一時的なコストが2倍になります。</li><li>新しいバージョンが問題ないか確認してから、前のバージョンを削除するため、デプロイが完了するまで時間がかかります。</li><li>サービスを利用する人によって見る画面が異なる時があるし、新しい機能を使えなくなるため、UX不一致問題が発生する可能性があります。</li></ul><p>新しい機能に対してA/Bテストをしたい場合、ユーザーアクセスが多い場合、このデプロイ方法を使います。また、開発中の機能をプロダクション環境でテストしたい場合にも使います。</p><h2 id="完了">完了</h2><p>これでソフトウェア開発におけるサービスデプロイ戦略の種類と使い方について説明しました。このブログポストが現在運用中のサービスとリソースに応じて適切なデプロイ戦略を選択するのに役立てば幸いです。</p>]]></content><author><name>dev.yakuza@gmail.com</name></author><category term="environment"/><summary type="html"><![CDATA[ソフトウェア開発におけるサービスデプロイ戦略の種類と使い方について説明します。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg"/><media:content medium="image" url="https://deku.posstree.com/assets/images/category/environment/2024/deployment-strategy/background.jpg" xmlns:media="http://search.yahoo.com/mrss/"/></entry></feed>